{
    "collab_server" : "",
    "contents" : "/** \n * @file SFMT.h \n *\n * @brief SIMD oriented Fast Mersenne Twister(SFMT) pseudorandom\n * number generator\n *\n * @author Mutsuo Saito (Hiroshima University)\n * @author Makoto Matsumoto (Hiroshima University)\n *\n * Copyright (C) 2006, 2007 Mutsuo Saito, Makoto Matsumoto and Hiroshima\n * University. All rights reserved.\n *\n * The new BSD License is applied to this software.\n * Copyright (c) 2006,2007 Mutsuo Saito, Makoto Matsumoto and Hiroshima\n *  University. All rights reserved.\n *\n *      Redistribution and use in source and binary forms, with or without\n *      modification, are permitted provided that the following conditions are\n *      met:\n *      \n *          - Redistributions of source code must retain the above copyright\n *          notice, this list of conditions and the following disclaimer.\n *          - Redistributions in binary form must reproduce the above\n *          copyright notice, this list of conditions and the following\n *          disclaimer in the documentation and/or other materials provided\n *          with the distribution.\n *          - Neither the name of the Hiroshima University nor the names of\n *          its contributors may be used to endorse or promote products\n *          derived from this software without specific prior written\n *          permission.\n *     \n *      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n *      \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n *      LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n *      A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n *      OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n *      SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n *      LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n *      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n *      THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n *      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n *      OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *  \n *\n * @note We assume that your system has inttypes.h.  If your system\n * doesn't have inttypes.h, you have to typedef uint32_t and uint64_t,\n * and you have to define PRIu64 and PRIx64 in this file as follows:\n * @verbatim\n typedef unsigned int uint32_t\n typedef unsigned long long uint64_t  \n #define PRIu64 \"llu\"\n #define PRIx64 \"llx\"\n@endverbatim\n * uint32_t must be exactly 32-bit unsigned integer type (no more, no\n * less), and uint64_t must be exactly 64-bit unsigned integer type.\n * PRIu64 and PRIx64 are used for printf function to print 64-bit\n * unsigned int and 64-bit unsigned int in hexadecimal format.\n */\n\n#ifndef SFMT_H\n#define SFMT_H\n\n#include <stdio.h>\n\n/*\n * code of Christophe Dutang \n * added to interface with R \n */\n/* ===================  my code  =================== */\n\n\n#include \"config.h\"\n\n/* 1234 = LIL_ENDIAN, 4321 = BIGENDIAN */\n#ifdef BYTEORDER\n  #if BYTEORDER == 4321\n    #define BIG_ENDIAN64 1\n  #elif BYTEORDER == 1234\n    #define LIL_ENDIAN 1\n  #else\n    #error wrong endianness!\n  #endif\n#endif\n\n//added to have _() error message in R\n#include \"locale.h\"\n\n//init SFMT parameters\nvoid init_SFMT(int mersennexponent, int useparamset);\n\n/* =================== end of my code =============== */\n\n#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)\n  #include <inttypes.h>\n  #define HAVE_INT32_64_DEFINED 1\n#elif defined(_MSC_VER) || defined(__BORLANDC__)\n  typedef unsigned int uint32_t;\n  typedef unsigned __int64 uint64_t;\n  #define inline __inline\n  #define HAVE_INT32_64_DEFINED 1\n#else\n  #include <inttypes.h>\n  #if defined(__GNUC__)\n    #define inline __inline__\n  #endif\n  #define HAVE_INT32_64_DEFINED 1\n#endif\n\n#ifndef PRIu64\n  #if defined(_MSC_VER) || defined(__BORLANDC__)\n    #define PRIu64 \"I64u\"\n    #define PRIx64 \"I64x\"\n  #else\n    #define PRIu64 \"llu\"\n    #define PRIx64 \"llx\"\n  #endif\n#endif\n\n#if defined(__GNUC__)\n  #define ALWAYSINLINE __attribute__((always_inline))\n#else\n  #define ALWAYSINLINE\n#endif\n\n#if defined(_MSC_VER)\n  #if _MSC_VER >= 1200\n    #define PRE_ALWAYS __forceinline\n  #else\n    #define PRE_ALWAYS inline\n  #endif\n#else\n  #define PRE_ALWAYS inline\n#endif\n\n\n\n/*\n * code of Christophe Dutang \n * added to interface with R \n */\n/* ===================  my code  =================== */\n\n#if (!HAVE_INTTYPES_H) && defined(HAVE_INTTYPES_H) && !defined(HAVE_INT32_64_DEFINED)\n  typedef unsigned int uint32_t;\n  #ifdef SIZEOF_UNSIGNED_LONG_LONG\n    typedef unsigned long long uint64_t;  \n  #else\n    typedef unsigned long uint64_t;  \n  #endif\n#endif\n\n#if !defined(PRIu64)\n  #define PRIu64 \"llu\"\n  #define PRIx64 \"llx\"\n#endif\n\n\n/* =================== end of my code =============== */\n\nuint32_t SFMT_gen_rand32(void);\nuint64_t gen_rand64(void);\nvoid fill_array32(uint32_t *array, int size);\nvoid fill_array64(uint64_t *array, int size);\nvoid SFMT_init_gen_rand(uint32_t seed);\nvoid SFMT_init_by_array(uint32_t *init_key, int key_length);\nconst char *get_idstring(void);\nint get_min_array_size32(void);\nint get_min_array_size64(void);\n\n/* These real versions are due to Isaku Wada */\n/** generates a random number on [0,1]-real-interval */\ninline static double to_real1(uint32_t v)\n{\n    return v * (1.0/4294967295.0); \n    /* divided by 2^32-1 */ \n}\n\n/** generates a random number on [0,1]-real-interval */\ninline static double SFMT_genrand_real1(void)\n{\n    return to_real1(SFMT_gen_rand32());\n}\n\n/** generates a random number on [0,1)-real-interval */\ninline static double to_real2(uint32_t v)\n{\n    return v * (1.0/4294967296.0); \n    /* divided by 2^32 */\n}\n\n/** generates a random number on [0,1)-real-interval */\ninline static double SFMT_genrand_real2(void)\n{\n    return to_real2(SFMT_gen_rand32());\n}\n\n/** generates a random number on (0,1)-real-interval */\ninline static double to_real3(uint32_t v)\n{\n    return (((double)v) + 0.5)*(1.0/4294967296.0); \n    /* divided by 2^32 */\n}\n\n/** generates a random number on (0,1)-real-interval */\ninline static double SFMT_genrand_real3(void)\n{\n    return to_real3(SFMT_gen_rand32());\n}\n/** These real versions are due to Isaku Wada */\n\n/** generates a random number on [0,1) with 53-bit resolution*/\ninline static double to_res53(uint64_t v) \n{ \n    return v * (1.0/18446744073709551616.0L);\n}\n\n/** generates a random number on [0,1) with 53-bit resolution from two\n * 32 bit integers */\ninline static double to_res53_mix(uint32_t x, uint32_t y) \n{ \n    return to_res53(x | ((uint64_t)y << 32));\n}\n\n/** generates a random number on [0,1) with 53-bit resolution\n */\ninline static double genrand_res53(void) \n{ \n    return to_res53(gen_rand64());\n} \n\n/** generates a random number on [0,1) with 53-bit resolution\n    using 32bit integer.\n */\ninline static double genrand_res53_mix(void) \n{ \n    uint32_t x, y;\n\n    x = SFMT_gen_rand32();\n    y = SFMT_gen_rand32();\n    return to_res53_mix(x, y);\n} \n#endif\n\n",
    "created" : 1521556612578.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1917582520",
    "id" : "50C23087",
    "lastKnownWriteTime" : 1493283534,
    "last_content_update" : 1493283534,
    "path" : "~/Documents/recherche-enseignement/code/R/rmetrics/Rmetrics2/rmetrics/pkg/randtoolbox/src/SFMT.h",
    "project_path" : "src/SFMT.h",
    "properties" : {
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "h"
}