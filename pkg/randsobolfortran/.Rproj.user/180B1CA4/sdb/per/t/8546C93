{
    "collab_server" : "",
    "contents" : "/** \n * @file  randtoolbox.c\n * @brief C file for all RNGs\n *\n * @author Christophe Dutang\n * @author Petr Savicky \n *\n *\n * Copyright (C) 2009, Christophe Dutang, \n * Petr Savicky, Academy of Sciences of the Czech Republic. \n * All rights reserved.\n *\n * The new BSD License is applied to this software.\n * Copyright (c) 2009 Christophe Dutang, Petr Savicky. \n * All rights reserved.\n *\n *      Redistribution and use in source and binary forms, with or without\n *      modification, are permitted provided that the following conditions are\n *      met:\n *      \n *          - Redistributions of source code must retain the above copyright\n *          notice, this list of conditions and the following disclaimer.\n *          - Redistributions in binary form must reproduce the above\n *          copyright notice, this list of conditions and the following\n *          disclaimer in the documentation and/or other materials provided\n *          with the distribution.\n *          - Neither the name of the Academy of Sciences of the Czech Republic\n *          nor the names of its contributors may be used to endorse or promote \n *          products derived from this software without specific prior written\n *          permission.\n *     \n *      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n *      \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n *      LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n *      A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n *      OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n *      SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n *      LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n *      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n *      THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n *      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n *      OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *  \n */\n/*****************************************************************************\n *  various Random Number Generators\n *\n *\t\tC functions\n *  \n *\tMany ideas are taken from <Rsource>/src/main/RNG.c\n *\n */\n\n#include \"randtoolbox.h\"\n\n/*********************************/\n/*              constants               */\n//the seed\nstatic unsigned long seed; \n//static unsigned long torusoffset;\n//a pseudo boolean to initiate the seed\nstatic int isInit=0;\n//the length (maximal) of the internal seed array for WELL44497\n#define LENSEEDARRAY 1391\nstatic unsigned int seedArray[LENSEEDARRAY];\n//a pseudo boolean to initiate the seed array\nstatic int isInitByArray=0;\n\n//the first 100 000 prime numbers computed from their differences stored in primes.h\nstatic int primeNumber[100000];\n\n// pi\nconst long double constpi = 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679 ;\nconst long double two_64_d = 18446744073709551616.0;\nconst uint64_t two_64m1_h = 0xffffffffffffffff;\n\n/*********************************/\n/*          utility functions         */\n\n//fractional part\nstatic R_INLINE double fracPart(double x)\n{\n  return x - floor(x);\n}\n\n\n/*********************************/\n/* quasi random generation */\n\n//main function used .Call()\nSEXP doTorus(SEXP n, SEXP d, SEXP p, SEXP offset, SEXP ismixed, SEXP timedseed, SEXP mersexpo)\n{\n  if (!isNumeric(n) || !isNumeric(d) || !isLogical(timedseed) || !isNumeric(mersexpo))\n    error(_(\"invalid argument\"));\n  \n  if(!isNull(p) && !isNumeric(p))           \n    error(_(\"invalid argument\"));\n  \n  \n  //temporary working variables\n  int nb = asInteger( n ); //number of random vectors\n  int dim  = asInteger( d ); //dimension of vector\n  int *prime; //prime numbers used when supplied\n  int seqstart = asInteger( offset ); //sequence starting point\n  int mixed = asLogical( ismixed ); //boolean to use the mixed Torus algo\n  int usetime = asLogical( timedseed ); //boolean to use the machine time\n  int mexp = asInteger( mersexpo );  //mersenne exponent\n  \n  if( isNull(p) )\n    prime = NULL; \n  else \n    prime  = INTEGER( p ); \n  \n  \n  //allocate result\n  double *u ; //result in C\n  SEXP resultinR; //result in R\n  PROTECT(resultinR = allocMatrix(REALSXP, nb, dim)); //allocate a n x d matrix\n  u = REAL( resultinR ); //plug the C pointer on the R type\n  \n  R_CheckStack();\n  \n  //computation step\n  if(prime == NULL)\n  {\n    if (primeNumber[2] == 1)\n      reconstruct_primes();\n    torus(u, nb, dim, primeNumber, seqstart, mixed, usetime, mexp);\n  } else\n    torus(u, nb, dim, prime, seqstart, mixed, usetime, mexp);\n  \n  UNPROTECT(1);\n  \n  return resultinR;\n}\n\n//compute the vector sequence of the Torus algorithm\n//pure QMC : offset is used ; ismixed=usetime=0\n//QMC with time machine : seed is used ; ismixed=0, usetime=1\n//hybrid QMC with SFMT : seed is used ; ismixed=1\nvoid torus(double *u, int nb, int dim, int *prime, int offset, int ismixed, int usetime, int mexp)\n{\n  int i, j;\n  unsigned long state;\n  \n  if (!R_FINITE(nb) || !R_FINITE(dim))\n    error(_(\"non finite argument\"));\n  \n  if(prime == NULL)    \n    error(_(\"internal error in torus function\"));\n  \n  //sanity check\n  if(dim > 100000) \n    error(_(\"Torus algorithm not yet implemented for dimension %d\"), dim);\n  \n  \n  //u_ij is the Torus sequence term \n  //with n = state + i, s = j + 1, p = primeNumber[j] or prime[j]\n  //u is stored column by column\n  \n  if(ismixed) //SF Mersenne-Twister-mixed Torus algo\n  { \n    //init SFMT parameters\n    init_SFMT(mexp, 0); //a single set of parameters\n    //init the seed of SF Mersenne Twister algo\n    SFMT_init_gen_rand(seed);\n    \n    \n    //Rprintf(\"state %lu\\n\", seed);\n    \n    //compute\n    for(j = 0; j < dim; j++)\n    {    \n      for(i = 0; i < nb; i++) \n      {\n        state = SFMT_gen_rand32();\n        //Rprintf(\"state %lu\\n\", state);\n        \n        u[i + j * nb] = fracPart( state * sqrt( prime[j] ) ) ;\n      }\n    }\n  }else //pure Torus algo\n  {\n    if(usetime) //use the machine time\n    {\n      //init the state of Torus algo (only for pure QMC and usetime=1)\n      if(!isInit && usetime) \n        randSeed();\n      state = ((unsigned int) seed >> 16);\n    }else \n      state  = offset;\n    \n    \n    //Rprintf(\"state %u %lu\\n\", state, state);\n    //compute\n    for(j = 0; j < dim; j++)\n      for(i = 0; i < nb; i++) \t\t\t\t\t\n        u[i + j * nb] = fracPart( ( state + i ) * sqrt( prime[j] ) ) ;                \n  }\n  \n  isInit = 0;\n}\n\nSEXP doHalton(SEXP n, SEXP d, SEXP offset, SEXP ismixed, SEXP timedseed, SEXP mersexpo)\n{\n  if (!isNumeric(n) || !isNumeric(d) || !isLogical(timedseed) || !isNumeric(mersexpo) )\n    error(_(\"invalid argument\"));\n  \n  //temporary working variables\n  int nb = asInteger( n ); //number of random vectors\n  int dim  = asInteger( d ); //dimension of vector\n  int seqstart = asInteger( offset ); //sequence starting point\n  int mixed = asLogical( ismixed ); //boolean to use the mixed Halton algo\n  int usetime = asLogical( timedseed ); //boolean to use the machine time\n  int mexp = asInteger( mersexpo );  //mersenne exponent\n  \n  //allocate result\n  double *u ; //result in C\n  SEXP resultinR; //result in R\n  PROTECT(resultinR = allocMatrix(REALSXP, nb, dim)); //allocate a n x d matrix\n  u = REAL( resultinR ); //plug the C pointer on the R type\n  \n  R_CheckStack();\n  \n  //computation step\n  if (primeNumber[2] == 1)\n    reconstruct_primes();\n  \n  halton_c(u, nb, dim, seqstart, mixed, usetime, mexp);\n  \n  UNPROTECT(1);\n  \n  return resultinR;\n}\n\n\n//compute the vector sequence of the Halton algorithm\nvoid halton_c(double *u, int nb, int dim, int offset, int ismixed, int usetime, int mexp)\n{\n  int i, j;\n  uint32_t state;\n  \n  if (!R_FINITE(nb) || !R_FINITE(dim))\n    error(_(\"non finite argument\"));\n  \n  //sanity check\n  if(dim > 100000)\n    error(_(\"Halton algorithm not yet implemented for dimension %d\"), dim);\n  \n  //u_ij is the Halton sequence term\n  //with n = state + i, s = j + 1, p = primeNumber[j]\n  //u is stored column by column\n  \n  if(ismixed) //SF Mersenne-Twister-mixed Torus algo\n  {\n    //init SFMT parameters\n    init_SFMT(mexp, 0); //a single set of parameters\n    //init the seed of SFMT\n    SFMT_init_gen_rand(seed);\n    //compute\n    for(j = 0; j < dim; j++)\n    {\n      for(i = 0; i < nb; i++)\n      {\n        state = SFMT_gen_rand32();\n        Rprintf(\"state %u %lu\\n\", state, state);\n        \n        u[i + j * nb] = HALTONREC( j, state ) ;\n      }\n    }\n  }else //classic Halton algo\n  {\n    if(usetime) //use the machine time\n    {\n      //init the seed of Halton algo\n      if(!isInit) \n        randSeed(); // (only for pure QMC and usetime=1)\n      state = ((unsigned int) seed >> 16);\n    }else\n      state  = offset;\n    \n    //Rprintf(\"state %u %lu\\n\", state, state);\n    for(j = 0; j < dim; j++)\n      for(i = 0; i < nb; i++)\n        u[i + j * nb] = HALTONREC( j, state + i ) ;\n  }\n  \n  isInit = 0;\n}\n\n\n\nSEXP doSobol(SEXP n, SEXP d, SEXP offset, SEXP ismixed, SEXP timedseed, SEXP mersexpo)\n{\n  if (!isNumeric(n) || !isNumeric(d) || !isLogical(timedseed) || !isNumeric(mersexpo))\n    error(_(\"invalid argument\"));\n  \n  //temporary working variables\n  int nb = asInteger( n ); //number of random vectors\n  int dim  = asInteger( d ); //dimension of vector\n  int seqstart = asInteger( offset ); //sequence starting point\n  int mixed = asLogical( ismixed ); //boolean to use the mixed Halton algo\n  int usetime = asLogical( timedseed ); //boolean to use the machine time\n  int mexp = asInteger( mersexpo );  //mersenne exponent\n  \n  //allocate result\n  double *u ; //result in C\n  SEXP resultinR; //result in R\n  PROTECT(resultinR = allocMatrix(REALSXP, nb, dim)); //allocate a n x d matrix\n  u = REAL( resultinR ); //plug the C pointer on the R type\n  \n  R_CheckStack();\n  \n  //computation step\n  if (primeNumber[2] == 1)\n    reconstruct_primes();\n  \n  sobol_c(u, nb, dim, seqstart, mixed, usetime, mexp);\n  \n  UNPROTECT(1);\n  \n  return resultinR;\n}\n\n\n\n//compute the vector sequence of the Halton algorithm\nvoid sobol_c(double *u, int nb, int dim, int offset, int ismixed, int usetime, int mexp)\n{\n  //temporary working variables\n  int i, j;\n  int ll;\n  //unsigned long state;\n  \n  int *sv; //possibly scrambled direction numbers\n  int maxbit=30; //maximum number of bits for direction numbers\n  //allocate temporary variables\n  sv = (int *) R_alloc(maxbit*dim, sizeof(int));\n  \n  \n  if (!R_FINITE(nb) || !R_FINITE(dim))\n    error(_(\"non finite argument\"));\n  \n  //sanity check\n  if(dim > 1111)\n    error(_(\"Sobol algorithm not yet implemented for dimension %d\"), dim);\n  \n  //init the seed [TO CHECK]\n  if(!isInit)\n    randSeed();\n  \n  INITSOBOL(dim, u, &ll, nb, sv, 0, seed);\n  \n  for(j = 0; j < dim; j++)\n  {\n    Rprintf(\"Direction %u\\n\", j);\n    for(i = 0; i < maxbit; i++)\n      Rprintf(\"%u,\", sv[i + j * maxbit]);\n    Rprintf(\"\\n\");\n  }\n  \n  //u_ij is the Sobol sequence term\n  //with n = state + i, s = j + 1, p = primeNumber[j]\n  //u is stored column by column\n  \n  for(j = 0; j < dim; j++)\n    for(i = 0; i < nb; i++)\n      u[i + j * nb] = 0.0;\n  \n  isInit = 0;\n}\n\n\n\n/***********************************/\n/* pseudo random generation */ \n\n//main function used .Call()\nSEXP doCongruRand(SEXP n, SEXP d, SEXP modulus, SEXP multiplier, SEXP increment, SEXP echo)\n{\n  if (!isNumeric(n) || !isNumeric(d))\n    error(_(\"invalid argument\"));\n  \n  //temporary working variables\n  int nb = asInteger( n ); //number of random vectors\n  int dim  = asInteger( d ); //dimension of vector\n  int show =  asLogical( echo ); //to show the seed\n  double modultemp = asReal( modulus ) ; //modulus as a double numeric\n  double multtemp = asReal( multiplier ) ; //multiplier as a double numeric\n  double incrtemp = asReal( increment ) ; //increment as a double numeric\n  uint64_t mod, mult, incr, mask; //modulus, multiplier, increment, mask\n  \n  Rprintf(\"mod %f\\n\", modultemp);\n  \n  //define a mask as in congruRand.c (function put_state_congru())\n  if (modultemp < two_64_d) //modulus lesser than 2^64 => mask=2^d-1 if mod = 2^d\n  {  \n    mod = (uint64_t) modultemp; //modulus below 2^64\n    if ((mod & (mod-1)) == 0)\n      mask = mod-1;\n    else\n      mask = 0;\n  }else //modulus greater or equal than 2^64 => mask=2^64-1 and mod=0 \n  {\n    mod = 0;\n    mask = two_64m1_h; \n  }\n  if (multtemp < two_64_d) \n    mult = (uint64_t) multtemp; //multiplier below 2^64\n  else\n    error(_(\"multiplier greater than 2^64-1\"));\n  if (incrtemp < two_64_d) \n    incr = (uint64_t) incrtemp; //increment below 2^64  \n  else\n    error(_(\"increment greater than 2^64-1\"));\n  \n  Rprintf(\"mask: %llu\\n\", mask);\n  Rprintf(\"modulus: %llu\\n\", mod);\n  Rprintf(\"multiplier: %llu\\n\", mult);\n  Rprintf(\"increment: %llu\\n\", incr);\n  \n  //result\n  double *u ; //result in C\n  SEXP resultinR; //result in R\n  PROTECT(resultinR = allocMatrix(REALSXP, nb, dim)); //allocate a n x d matrix\n  u = REAL( resultinR ); //plug the C pointer on the R type\n  \n  R_CheckStack();\n  \n  //computation step\n  congruRand(u, nb, dim, mod, mult, incr, mask, show);\n  \n  UNPROTECT(1);\n  \n  return resultinR;\n}\n\n//compute the sequence of a general congruential linear generator\nvoid congruRand(double *u, int nb, int dim, uint64_t mod, uint64_t mult, uint64_t incr, uint64_t mask, int show)\n{\n  int i, j, err;\n  uint64_t temp;\n  \n  if (!R_FINITE(nb) || !R_FINITE(dim))\n    error(_(\"non finite argument\"));\n  \n  //initiate the seed with the machine time\n  // and ensure it is positive\n  if(!isInit) \n  {    \n    do randSeed() ; \n    while ( seed <= 0 );\n  }\n  \n  //u_ij is the nth (n = i + j * nb) term of a general congruential linear generator\n  //i.e. u_ij = [ ( mult * x_{n-1}  + incr ) % mod ] / mod\n  //u is stored column by column\n  if (mod > 0) \n    seed = seed % mod;\n  err = check_congruRand(mod, mask, mult, incr, (uint64_t) seed);\n  if (err < 0)\n    error(_(\"incorrect parameters of the generator %d\"), err);\n  set_congruRand(mod, mult, incr, (uint64_t) seed, mask);\n  \n  if(!show) \n  {\n    for(i = 0; i < nb; i++)\n    {\n      for(j = 0; j < dim; j++) \n      {\n        u[i + j * nb] = get_congruRand();\n      }\n    }\n  }else //show the seed\n  {    \n    for(i = 0; i < nb; i++)\n    {\n      for(j = 0; j < dim; j++) \n      {\n        get_seed_congruRand((uint64_t*) &temp);\n        Rprintf(\"%u th integer generated : %\" PRIu64 \"\\n\", 1+ i + j * nb, temp);\n        u[i + j * nb] = get_congruRand();\n      }\n    }\n  }\n  \n  isInit = 0;\n}\n\n//main function used .Call()\nSEXP doSFMersenneTwister(SEXP n, SEXP d, SEXP mersexpo, SEXP paramset)\n{\n  if (!isNumeric(n) || !isNumeric(d) || !isNumeric(mersexpo) || !isLogical(paramset))\n    error(_(\"invalid argument\"));\n  \n  //temporary working variables\n  int nb = asInteger( n ); //number of random vectors\n  int dim  = asInteger( d ); //dimension of vector\n  int mexp = asInteger( mersexpo );  //mersenne exponent\n  int usepset = asLogical( paramset ); //use param sets\n  \n  //result\n  double *u ; //result in C\n  SEXP resultinR; //result in R\n  PROTECT(resultinR = allocMatrix(REALSXP, nb, dim)); //allocate a n x d matrix\n  u = REAL( resultinR ); //plug the C pointer on the R type\n  \n  R_CheckStack();\n  \n  //computation step\n  SFmersennetwister(u, nb, dim, mexp, usepset );\n  \n  UNPROTECT(1);\n  return resultinR;   \n}\n\n// call the SF mersenne twister of Matsumoto and Saito\nvoid SFmersennetwister(double *u, int nb, int dim, int mexp, int usepset)\n{\n  int i, j;\n  \n  //initiate the seed with the machine time\n  // and ensure it is positive\n  if(!isInit) \n  {    \n    do randSeed() ; \n    while ( seed <= 0 );\n  }\n  \n  //init SFMT parameters\n  init_SFMT(mexp, usepset);\n  //init the seed of SFMT\n  SFMT_init_gen_rand(seed);\n  \n#if defined(HAVE_SSE2)\t\n  //size of internal array\n  int blocksize = get_min_array_size32();\n#endif\n  \n  //number of blocks to generate\n  //int nbblock = nb / blocksize; \n  //last variates to generate\n  //int rest = nb % blocksize;\n  \n  \n  \n  //Rprintf(\"zog\\n\");\n  \n  //    PROTECT(array = allocMatrix(INTSXP, nb, dim)); //allocate a n x d matrix\n  \n  \n  /*\n   * @param size the number of 32-bit pseudorandom integers to be\n   * generated.  size must be a multiple of 4, and greater than or equal\n   * to (MEXP / 128 + 1) * 4.\n   */\n#if defined(HAVE_SSE2)    \n  if(nb * dim >= blocksize)\n  {\n    \n    //unsigned int *array;\n    //        static __m128i array1[BLOCK_SIZE / 4];\n    //        static __m128i array2[10000 / 4];\n    \n    __m128i array1[nb * dim*4];\n    \n    uint32_t *array32 = (uint32_t *)array1;\n    \n    //        array = (unsigned int *) R_alloc(nb * dim, sizeof(__m128i));\n    \n    fill_array32(array32, nb*dim);\n    \n    // compute u_ij\n    for(j = 0; j < dim; j++)\n      for(i = 0; i < nb; i++) \n        u[i + j * nb] = to_real3( array32[i + j * nb] ); // real on ]0,1[ interval\n    \n    \n    //Free(array);\n  }\n  else\n  {\n#endif        \n    \n    \n    // compute u_ij\n    for(j = 0; j < dim; j++)\n      for(i = 0; i < nb; i++) \n        u[i + j * nb] = SFMT_genrand_real3(); // real on ]0,1[ interval\n    \n#if defined(HAVE_SSE2)\n  }\n#endif\n  \n  \n  isInit = 0;\n}\n\n//main function used .Call()\nSEXP doWELL(SEXP n, SEXP d, SEXP order, SEXP tempering, SEXP version)\n{\n  if (!isNumeric(n) || !isNumeric(d) || !isNumeric(order) || !isLogical(tempering) || !isNumeric(version))\n    error(_(\"invalid argument\"));\n  \n  //temporary working variables\n  int nb = asInteger( n ); //number of random vectors\n  int dim  = asInteger( d ); //dimension of vector\n  int degree = asInteger( order );  //mersenne exponent\n  int dotemper = asLogical( tempering ); //tempering or not?\n  int theversion = asInteger( version ); //1 for 'a' version and 2 for 'b'\n  \n  //result\n  double *u ; //result in C\n  SEXP resultinR; //result in R\n  PROTECT(resultinR = allocMatrix(REALSXP, nb, dim)); //allocate a n x d matrix\n  u = REAL( resultinR ); //plug the C pointer on the R type\n  \n  R_CheckStack();\n  \n  //computation step\n  WELLrng(u, nb, dim, degree, dotemper, theversion);\n  \n  UNPROTECT(1);\n  \n  return resultinR;   \n}\n\n\n\n//main function used .Call()\nSEXP doKnuthTAOCP(SEXP n, SEXP d)\n{\n  if (!isNumeric(n) || !isNumeric(d))\n    error(_(\"invalid argument\"));\n  \n  //temporary working variables\n  int nb = asInteger( n ); //number of random vectors\n  int dim  = asInteger( d ); //dimension of vector\n  \n  //result\n  double *u ; //result in C\n  SEXP resultinR; //result in R\n  PROTECT(resultinR = allocMatrix(REALSXP, nb, dim)); //allocate a n x d matrix\n  u = REAL( resultinR ); //plug the C pointer on the R type\n  \n  R_CheckStack();\n  \n  //computation step\n  knuthTAOCP(u, nb, dim);\n  \n  UNPROTECT(1);\n  \n  return resultinR;   \n}\n\n// call the Knuth 'The Art Of Computer Programming' RNG\nvoid knuthTAOCP(double *u, int nb, int dim)\n{\n  int i, j;\n  \n  //initiate the seed with the machine time\n  // and ensure it is positive\n  if(!isInit) \n  {    \n    do randSeed() ; \n    while ( seed <= 0 );\n  }\n  \n  //init TAOCP RNG\n  ranf_start( seed );\n  \n  //ranf_arr_cycle();\n  \n  // compute u_ij's\n  // declare an array a little bit longer than KK (100) long lag if too short\n  // see Knuth's file for details\n  if( nb * dim <= 100 )\n  {\n    double * temp = (double *) R_alloc( 101, sizeof(double) );\n    \n    ranf_array( temp, 101 );\n    \n    for(j = 0; j < dim; j++)\n      for(i = 0; i < nb; i++) \n        u[i + j * nb] = temp[i + j * nb]; // real on ]0,1[ interval\n    \n  }\n  else\n    ranf_array( u, nb*dim );\n\n  //Rprintf(\"1st term %.20f --- seed  %u\\n\", u[0], seed);\n  isInit = 0;\n}\n\n\n/**********************************/\n/*          set the seed                */\n\n//main function used .Call()\n//seed set by the user\n//idea taken from the R internal C function do_setseed\nSEXP doSetSeed(SEXP s)\n{\n  if (!isNumeric(s))\n    error(_(\"invalid argument\"));\n  \n  setSeed( (long) asInteger(s) );\n  \n  return R_NilValue;\n}\n\nvoid setSeed(long s)\n{\n  if (!R_FINITE(s))\n    error(_(\"non finite seed\"));\n  \n  seed = s;\n  isInit = 1;\n  isInitByArray = 0;\n}\n\n//randomize and set the seed when not initialized\n//idea taken from the R internal C function Randomize()\nvoid randSeed()\n{\n  \n#if HAVE_SYS_TIME_H\n{\n  /* \n   * UTC time since the Epoch, i.e. 01/01/1970 00:00:00\n   struct timeval {  \n   unsigned long tv_sec; // seconds \n   long tv_usec; // and microseconds  }; \n   * see http://opengroup.org/onlinepubs/007908799/xsh/systime.h.html\n   */\n  \n  struct timeval tv;\n  gettimeofday (&tv, NULL);\n  \n  seed = ((unsigned long long) tv.tv_usec << 16) ^ tv.tv_sec;\n}\n#elif HAVE_WINDOWS_H\n{\n  /* \n   * UTC time since the Epoch, i.e. 01/01/1970 00:00:00\n   typedef struct _SYSTEMTIME {\n   WORD wYear;\n   WORD wMonth;\n   WORD wDayOfWeek;\n   WORD wDay;\n   WORD wHour;\n   WORD wMinute;\n   WORD wSecond;\n   WORD wMilliseconds;\n   } SYSTEMTIME, \n   *PSYSTEMTIME;\n   * see http://msdn.microsoft.com/en-us/library/ms724950(VS.85).aspx\n   */\n  \n  SYSTEMTIME tv;\n  GetSystemTime(&tv);\n  \n  /*\n   *  typedef union _LARGE_INTEGER {\n   struct {\n   DWORD LowPart;\n   LONG HighPart;\n   } ;\n   struct {\n   DWORD LowPart;\n   LONG HighPart;\n   } u;\n   LONGLONG QuadPart;\n   } LARGE_INTEGER, \n   *PLARGE_INTEGER;\n   * see http://msdn.microsoft.com/en-us/library/aa383713(VS.85).aspx \n   */\n  \n  LARGE_INTEGER count;\n  QueryPerformanceCounter( (LARGE_INTEGER *) &count );        \n  \n  seed = (unsigned long long) ( ( (tv.wMilliseconds << 16) ^ tv.wSecond ) + count.LowPart );\n}\n#elif HAVE_TIME_H\n{\n  /* \n   * UTC time since the Epoch, i.e. 01/01/1970 00:00:00\n   type time_t  \n   tv_sec    seconds\n   * see http://opengroup.org/onlinepubs/007908799/xsh/time.h.html\n   */\n  \n  seed = ((unsigned long) time(NULL) <<16);\n}\n#else\n/* unlikely, but use random contents */\n#endif\n\nisInit = 1;\n}   \n\n//initialize internal state array, idea taken from Matsumoto's code dSFMT\nvoid randSeedByArray(int length)\n{\n  int i;\n  //unsigned long long int temp = 1;\n  \n  if( length > LENSEEDARRAY)\n    error(_(\"error while initializing WELL generator\\n\"));\n  \n  if (!isInit) randSeed();\n  \n  // same initialisation as dSFMT 1.3.0 from Matsumoto and Saito\n  seedArray[0] = seed;\n  for (i = 1; i < length; i++) \n    seedArray[i] = 1812433253UL * ( seedArray[i - 1] ^ ( seedArray[i - 1] >> 30 ) ) + i;\n  \n  isInit = 0;\n  isInitByArray = 1;\n}\n\n\n\n/**************/\n/* constants */\n//the first 100 000 prime numbers taken from http://primes.utm.edu/\n#include \"primes.h\"\n\nvoid reconstruct_primes()\n{\n  int i;\n  if (primeNumber[2] == 1)\n    for (i = 2; i < 100000; i++)\n      primeNumber[i] = primeNumber[i-1] + 2*primeNumber[i];\n}\n\nvoid get_primes(int *n, int *pri)\n{\n  int i;\n  if (primeNumber[2] == 1)\n    reconstruct_primes();\n  for (i = 0; i < *n; i++)\n    pri[i] = primeNumber[i];\n}\n\n",
    "created" : 1521535009670.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3449412258",
    "id" : "8546C93",
    "lastKnownWriteTime" : 1521556818,
    "last_content_update" : 1521556818669,
    "path" : "~/Documents/recherche-enseignement/code/R/rmetrics/Rmetrics2/rmetrics/pkg/randtoolbox/src/randtoolbox.c",
    "project_path" : "src/randtoolbox.c",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "c"
}