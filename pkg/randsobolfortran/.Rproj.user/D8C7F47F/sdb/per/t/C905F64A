{
    "collab_server" : "",
    "contents" : "/** \n * @file  congruRand.c\n * @brief C file for congruential RNG\n *\n * @author Christophe Dutang\n * @author Petr Savicky \n *\n *\n * Copyright (C) 2014, Christophe Dutang,\n * Petr Savicky, Academy of Sciences of the Czech Republic. \n * All rights reserved.\n *\n * The new BSD License is applied to this software.\n * Copyright (c) 2014 Christophe Dutang, Petr Savicky. \n * All rights reserved.\n *\n *      Redistribution and use in source and binary forms, with or without\n *      modification, are permitted provided that the following conditions are\n *      met:\n *      \n *          - Redistributions of source code must retain the above copyright\n *          notice, this list of conditions and the following disclaimer.\n *          - Redistributions in binary form must reproduce the above\n *          copyright notice, this list of conditions and the following\n *          disclaimer in the documentation and/or other materials provided\n *          with the distribution.\n *          - Neither the name of the Academy of Sciences of the Czech Republic\n *          nor the names of its contributors may be used to endorse or promote \n *          products derived from this software without specific prior written\n *          permission.\n *     \n *      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n *      \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n *      LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n *      A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n *      OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n *      SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n *      LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n *      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n *      THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n *      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n *      OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *  \n */\n/*****************************************************************************\n *  Congruential random number generators\n *    \n *      C file\n *\n */\n\n\n#include \"congruRand.h\"\n#include \"runifInterface.h\"\n\n#define two_64_d 18446744073709551616.0\n#define two_64m1 18446744073709551615ULL\n#define two_64_s \"18446744073709551616\"\n#define two_64m1_h 0xffffffffffffffff\n\n\n\n\n// general linear congruential generator\n\nuint64_t mod, mask, mult, incr, congru_seed;\n\n// possible value of user_unif_rand_selected in runifInterface.c\ndouble user_unif_rand_congru_0()\n{\n\tdouble x;\n\tcongru_seed  = (mult * congru_seed + incr) % mod;\n\tx = (double) congru_seed / (double) mod;\n\tif (x == 0.0) {\n\t\tx = 0.5 / (double) mod;\n\t}\n\treturn x;\n}\n\n// possible value of user_unif_rand_selected in runifInterface.c\ndouble user_unif_rand_congru_1()\n{\n\tdouble x;\n\tcongru_seed  = (mult * congru_seed + incr) & mask;\n\tx = (double) congru_seed / (double) mod;\n\tif (x == 0.0) {\n\t\tx = 0.5 / (double) mod;\n\t}\n\treturn x;\n}\n\n// possible value of user_unif_rand_selected in runifInterface.c\ndouble user_unif_rand_congru_2()\n{\n\tdouble x;\n\tcongru_seed  = (mult * congru_seed + incr);\n\tx = (double) congru_seed / two_64_d;\n\tif (x == 0.0) {\n\t\tx = 0.5 / two_64_d;\n\t}\n\treturn x;\n}\n\n// possible value of user_unif_init_selected in runifInterface.c\nvoid user_unif_init_congru(uint32_t seed)\n{\n\tcongru_seed = (uint64_t) seed;\n}\n\n// called from randtoolbox.c from congruRand function\ndouble get_congruRand()\n{\n\tdouble x;\n\tcongru_seed  = (mult * congru_seed + incr) % mod;\n\tx = (double) congru_seed / (double) mod;\n\tif (x == 0.0) {\n\t\tx = 1.0;\n\t}\n\treturn x;\n}\n\n// check several criteria on parameters\nint check_congruRand(uint64_t mod, uint64_t mask,\n\tuint64_t mult, uint64_t incr,\n\tuint64_t seed)\n{\n\tif (mult == 0LL) return - 1;\n\tif (mask == 0LL) {\n\t\tif (mult >= mod) return - 2;\n\t\tif (incr >= mod) return - 3;\n\t\tif (mod - 1 > (two_64m1 - incr) / mult) return - 4;\n\t\tif (seed >= mod) return - 5;\n\t\treturn 0;\n\t} else {\n\t\tif (mult > mask) return - 12;\n\t\tif (incr > mask) return - 13;\n\t\tif (seed > mask) return - 14;\n\t\tif (mask == two_64m1_h) return 2;\n\t\treturn 1;\n\t}\n}\n\n// set parameters\nvoid set_congruRand(uint64_t inp_mod, uint64_t inp_mult,\n\t\tuint64_t inp_incr, uint64_t inp_seed)\n{\n\tmod = inp_mod;\n\tmult = inp_mult;\n\tincr = inp_incr;\n\tcongru_seed = inp_seed;\n}\n\n// get seed\nvoid get_seed_congruRand(uint64_t *out_seed)\n{\n\t*out_seed = congru_seed;\n}\n\n// .C entry point used by get.description\nvoid get_state_congru(char **params, char **seed)\n{\n\tif (mod != 0LL) {\n\t\tRprintf(params[0], \"%\" PRIu64 \"\\n\", mod);\n\t} else {\n\t\tstrcpy(params[0], two_64_s);\n\t}\n\tRprintf(params[1], \"%\" PRIu64 \"\\n\", mult);\n\tRprintf(params[2], \"%\" PRIu64 \"\\n\", incr);\n\tRprintf(seed[0], \"%\" PRIu64 \"\\n\", congru_seed);\n}\n\n// .C entry point used by put.description\nvoid put_state_congru(char **params, char **seed, int *err)\n{\n\tuint64_t inp_mod, inp_mask, inp_mult, inp_incr, inp_seed;\n\tif (strcmp(params[0], two_64_s) == 0) {\n\t\tinp_mod = 0;\n\t\tinp_mask = two_64m1_h;\n\t} else {\n\t\tsscanf(params[0], \"%\" PRIu64 \"\\n\", &inp_mod);\n\t\tif ((inp_mod & (inp_mod - 1)) == 0) {\n\t\t\tinp_mask = inp_mod - 1;\n\t\t} else {\n\t\t\tinp_mask = 0;\n\t\t}\n\t}\n\tsscanf(params[1], \"%\" PRIu64 \"\\n\", &inp_mult);\n\tsscanf(params[2], \"%\" PRIu64 \"\\n\", &inp_incr);\n\tsscanf(seed[0], \"%\" PRIu64 \"\\n\", &inp_seed);\n\t*err = check_congruRand(inp_mod, inp_mask, inp_mult, inp_incr, inp_seed);\n\n\tif (*err < 0) return;\n\tmod = inp_mod;\n\tmask = inp_mask;\n\tmult = inp_mult;\n\tincr = inp_incr;\n\tcongru_seed = inp_seed;\n\tswitch (*err) {\n\tcase 0:\n\t\tuser_unif_set_generator(1, user_unif_init_congru, user_unif_rand_congru_0);\n\t\tbreak;\n\tcase 1:\n\t\tuser_unif_set_generator(1, user_unif_init_congru, user_unif_rand_congru_1);\n\t\tbreak;\n\tcase 2:\n\t\tuser_unif_set_generator(1, user_unif_init_congru, user_unif_rand_congru_2);\n\t}\n\t*err = 0;\n}\n\n",
    "created" : 1500698525974.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3801211489",
    "id" : "C905F64A",
    "lastKnownWriteTime" : 1493283534,
    "last_content_update" : 1500699297805,
    "path" : "~/Documents/recherche-enseignement/code/R/rmetrics/Rmetrics2/rmetrics/pkg/randtoolbox/src/congruRand.c",
    "project_path" : "src/congruRand.c",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "c"
}