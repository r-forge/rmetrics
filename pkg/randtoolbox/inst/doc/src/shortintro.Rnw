
Random simulation or Monte-Carlo methods rely on the fact we have access to random
numbers. Even if nowadays having random sequence is no longer a problem, for many
years producing random numbers was a big challenge. According to \cite{ripleybook},
simulation started in 1940s with physical devices. It brings us to a point we need
to take care is the kind simulation we deal with. Using physical phenomena to get
random numbers is referred in the literature as true randomness.

However, in our computers, we use more frequently pseudo-random numbers.
These are defined as deterministic sequences, which mimic a sequence of
i.i.d. random numbers chosen from the uniform distribution on the interval
$[0,1]$. Random number generators used for this purpose receive as input
an initial information, which is called a user specified seed, and allow
to obtain different output sequences of numbers from $[0,1]$ depending
on the seed. If no seed is supplied by the user, we use the machine time
to initiate the sequence.


Since we use fake random numbers as a proxy for random numbers, one important question
is the desired properties of RNG. \cite{ripleybook} lists the following properties
\begin{itemize}
\item output numbers are almost uniformly distributed,
\item output numbers are independent,
\item the period between two identical numbers is sufficiently long,
\item unless a seed is given, output numbers should be unpredictable.
\end{itemize}

The statistical software \soft{R} provides several random number generators described
in '?RNGkind()'. The default generator is called Mersenne-Twister and achieves high
quality. 

Still, there are reasons to provide better and more recent RNGs as well as classic
statistical tests to quantify their property. The rest of this chapter is
two-folded: first we present the use of RNGs through the \code{runif} interface,
second we present the same use with dedicated functions (not modifying base \soft{R}
default RNGs). See the overall man page with this command \code{?randtoolbox}.


\section{The \code{runif} interface}

In \soft{R}, the default setting for random generation are (i) uniform numbers are
produced by the Mersenne-Twister algorithm and (ii) normal numbers are computing
through the numerical inversion of the standard normal distribution function. This
can be checked by the following code
%%% R code
<<check, fig=FALSE, echo=TRUE, eval=TRUE>>=
RNGkind()
@
%%%
The function \code{RNGkind()} can also be used to set other RNGs, such as Wichmann-Hill,
Marsaglia-Multicarry, Super-Duper, Knuth-TAOCP or Knuth-TAOCP-2002 plus a
user-supplied RNG. See the help page for details. 

Random number generators provided by R extension packages are set
using \code{RNGkind("user-supplied")}.
The package \pkg{randtoolbox} assumes that this function is not called by the user directly.
Instead, it is called from the functions \code{set.generator()} and \code{put.description()} used
for setting some of a larger collection of the supported generators.

The function \code{set.generator()} eases the process to set a new RNG in \soft{R}.
Here is one short example on how to use \code{set.generator} (see the man page
for detailed explanations).

%%% R code
<<example1, fig=FALSE, echo=TRUE, eval=TRUE>>=
RNGkind()
library(randtoolbox)
paramParkMiller <- c(mod=2^31-1, mult=16807, incr=0)
set.generator(name="congruRand", parameters=paramParkMiller, seed=1)
get.description()
RNGkind()
runif(10)
@
%%%

Random number generators in \pkg{randtoolbox} are represented at the R level by a list
containing mandatory components \code{name, parameters, state} and possibly an
optional component \code{authors}. The function \code{set.generator()} internally
creates this list from the user supplied information and then runs \code{put.description()}
on this list in order to really initialize the generator for the functions \code{runif()}
and \code{set.seed()}. If \code{set.generator()} is called with the parameter
\code{only.dsc=TRUE}, then the generator is not initialized and only
its description is created. If the generator is initialized, then the function
\code{get.description()} may be used to get the actual
state of the generator, which may be stored and used later in \code{put.description()}
to continue the sequence of the random numbers from the point, where \code{get.description()}
was called. This may be used, for example, to alternate between the streams of random numbers
generated by different generators.

From the \code{runif} interface, you can use any other linear congruential
generators (as long as the parameters can be set in \soft{R}) and
Well-Equidistributed Long-period Linear generators (WELL).

To get back to the original setting of RNGs in \soft{R}, we just need to
call \code{set.generator} with \code{default} RNG. 
%%% R code  
<<undo, fig=FALSE, echo=TRUE, eval=TRUE>>=
set.generator("default")
RNGkind()
@
%%%

\section{Dedicated functions}
The other way to use RNGs is to directly use dedicated functions. For instance to
get the previous example, we can simply use
%%% R code
<<example1, fig=FALSE, echo=TRUE, eval=TRUE>>=
setSeed(1)
congruRand(10, mod = 2^31-1, mult = 16807, incr = 0)
@
%%%
where \code{setSeed} function initiates the seed for RNGs implemented in
\pkg{randtoolbox} and \code{congruRand} calls the congruential generator.

They are many other RNGs provided by RNGs in addition to linear congruential
generator, WELL generators, SFMersenne-Twister generators and Knuth-TAOCP
double version. See \code{?pseudo.randtoolbox} for details.

This package also implements usual quasi random generators such as Sobol or
Halton sequences (see \code{?quasi.randtoolbox}). See the second chapter
for an explanation on quasi RNGs.

