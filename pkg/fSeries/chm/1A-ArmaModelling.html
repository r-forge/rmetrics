<html><head><title>Integrated ARMA Time Series Modelling</title>
<link rel="stylesheet" type="text/css" href="Rchm.css">
</head>
<body>

<table width="100%"><tr><td>ArmaModelling(fSeries)</td><td align="right">R Documentation</td></tr></table><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e">
<param name="keyword" value="R:   ArmaModelling">
<param name="keyword" value="R:   fARMA">
<param name="keyword" value="R:   fARMA-class">
<param name="keyword" value="R:   armaSim">
<param name="keyword" value="R:   armaFit">
<param name="keyword" value="R:   print.fARMA">
<param name="keyword" value="R:   plot.fARMA">
<param name="keyword" value="R:   summary.fARMA">
<param name="keyword" value="R:   predict.fARMA">
<param name="keyword" value="R:   fitted.fARMA">
<param name="keyword" value="R:   coef.fARMA">
<param name="keyword" value="R:   residuals.fARMA">
<param name="keyword" value="R:   armaRoots">
<param name="keyword" value="R:   armaTrueacf">
<param name="keyword" value=" Integrated ARMA Time Series Modelling">
</object>


<h2>Integrated ARMA Time Series Modelling</h2>


<h3>Description</h3>

<p>
A collection and description of simple to 
use functions to model univariate autoregressive 
moving average time series processes, including 
time series simulation, parameter estimation, 
diagnostic analysis of the fit, and predictions 
of future values.
<br>
</p>
<p>
The functions are:
</p>

<table summary="Rd table">
<tr>
  <td align="left"><code>armaSim</code> </td>  <td align="left"> Simulates an artificial ARMA time series process, </td>
</tr>
<tr>
  <td align="left"> <code>armaFit</code> </td>  <td align="left"> Fits the parameters of an ARMA time series process,</td>
</tr>
<tr>
  <td align="left"> <code>print</code> </td>  <td align="left"> S3 Print Method, </td>
</tr>
<tr>
  <td align="left"> <code>plot</code> </td>  <td align="left"> S3 Plot Method, </td>
</tr>
<tr>
  <td align="left"> <code>summary</code> </td>  <td align="left"> S3 Summary Method, </td>
</tr>
<tr>
  <td align="left"> <code>predict</code> </td>  <td align="left"> Forecasts and optionally plots an ARMA process, </td>
</tr>
<tr>
  <td align="left"> <code>fitted</code> </td>  <td align="left"> S3 Method, returns fitted values, </td>
</tr>
<tr>
  <td align="left"> <code>coef|coefficients</code> </td>  <td align="left"> S3 Method, returns coefficients, </td>
</tr>
<tr>
  <td align="left"> <code>residuals</code> </td>  <td align="left"> S3 Method, returns residuals. </td>
</tr>
</table>

<p>
The functions for the analysis of an true ARMA process are:
</p>

<table summary="Rd table">
<tr>
  <td align="left"><code>armaRoots</code> </td>  <td align="left"> Roots of the characteristic ARMA polynomial, </td>
</tr>
<tr>
  <td align="left"> <code>armaTrueacf</code> </td>  <td align="left"> True autocorrelation function of an ARMA process.</td>
</tr>
</table>


<h3>Usage</h3>

<pre>
armaSim(model = list(ar = c(0.5, -0.5), d = 0, ma = 0.1), n = 100, 
    innov = NULL, n.start = 100, start.innov = NULL, rand.gen = rnorm, 
    rseed = NULL, ...) 

armaFit(formula = x ~ arima(2, 0, 1), method = c("mle", "ols"), 
    include.mean = TRUE, fixed = NULL, fracdiff.M = 100, fracdiff.h = -1, 
    title = NULL, description = NULL, ...)

## S3 method for class 'fARMA':
print(x, ...)
## S3 method for class 'fARMA':
plot(x, which = "ask", gof.lag = 10, ...)
## S3 method for class 'fARMA':
summary(object, doplot = TRUE, which = "all", ...)

## S3 method for class 'fARMA':
predict(object, n.ahead = 10, n.back = 50, conf = c(80, 95), 
    doplot = TRUE, ...)
    
## S3 method for class 'fARMA':
fitted(object, ...)
## S3 method for class 'fARMA':
coef(object, ...)
## S3 method for class 'fARMA':
residuals(object, ...)

armaRoots(coefficients, n.plot = 400, digits = 4, ...) 
armaTrueacf(model, lag.max = 20, type = c("correlation", "partial", "both"), 
    doplot = TRUE) 
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>coefficients</code></td>
<td>
[armaRoots] - <br>
a numeric vector with the coefficients of the characterisitic 
polynomial.
</td></tr>
<tr valign="top"><td><code>description</code></td>
<td>
a character string which allows for a brief description.
</td></tr>
<tr valign="top"><td><code>digits</code></td>
<td>
[armaRoots] - <br>
output precision, an integer value.
</td></tr>
<tr valign="top"><td><code>doplot</code></td>
<td>
[armaRoots] - <br>
a logical. Should a plot be displayed?
<br>
[predict][summary] - <br>
is used by the <code>predict</code> and <code>summary</code> methods. By default,
this value is set to <code>TRUE</code> and thus the function calls generate 
beside written also graphical printout.
Additional arguments required by underlying functions have 
to be passed through the <code>dots</code> argument.
</td></tr>
<tr valign="top"><td><code>fixed</code></td>
<td>
[armaFit] - <br>
is an optional numeric vector of the same length as the total
number of parameters. If supplied, only <code>NA</code> entries in
<code>fixed</code> will be varied. In this way subset ARMA processes
can be modeled. ARIMA modelling supports this option. Thus
for estimating parameters of subset ARMA and AR models the 
most easiest way is to specify them by the formulas 
<code>x~ARIMA(p, 0, q)</code> and <code>x~ARIMA(p, 0, 0)</code>, respectively.
</td></tr>
<tr valign="top"><td><code>formula</code></td>
<td>
[armaFit] - <br>
a formula specifying the general structure of the ARMA form. 
Can have one of the forms  
<code>x ~ ar(q)</code>, 
<code>x ~ ma(p)</code>, 
<code>x ~ arma(p, q)</code>, 
<code>x ~ arima(p, d, q)</code>, or
<code>x ~ fracdiff(p, q)</code>.
<code>x</code> is the response variable and must appear in the 
formula expression.
In the first case R's function <code>ar</code> from the <code>ts</code>
package will be used to estimate the parameters, in the second
case R's function <code>arma</code> from the <code>tseries</code> package
will be used, in the third case R's function <code>arima</code> from 
the <code>ts</code> package will be used, and in the last case R's
function <code>fracdiff</code> from the <code>fracdiff</code> package will
be used. The state space modelling based <code>arima</code> function
allows also to fit ARMA models using <code>arima(p, d=0, q)</code>, and
AR models using <code>arima(q, d=0, q=0)</code>, or pure MA models
using <code>arima(q=0, d=0, p)</code>. (Exogenous variables are also 
allowed and can be passed through the <code>...</code> argument.)
</td></tr>
<tr valign="top"><td><code>fracdiff.M, fracdiff.h</code></td>
<td>
two numeric parameter values for the <code>"fracdiff"</code> 
estimator. <code>M</code> is the number of terms in the likelihood 
approximation. <code>h</code> is the size of the finite difference 
interval for numerical derivatives. By default, or if negative, 
<code>h=min(0.1,eps.5*(1+ abs(cllf)))</code>, where 
<code>clff:=log.max.likelihood</code>, as returned, and 
<code>eps.5:=sqrt(.Machine$double.neg.eps)</code>, typically 
<code>1.05e-8</code>.
</td></tr>
<tr valign="top"><td><code>gof.lag</code></td>
<td>
[print][plot][summary][predict] - <br>
the maximum number of lags for a goodness-of-fit test.
</td></tr>
<tr valign="top"><td><code>include.mean</code></td>
<td>
[armaFit] - <br>
Should the ARIMA model include a mean term? The default is 
<code>TRUE</code>, note that for differenced series a mean would 
not affect the fit nor predictions.
</td></tr>
<tr valign="top"><td><code>innov</code></td>
<td>
[armaSim] - <br>
is a univariate time series or vector of innovations to produce 
the series. If not provided, <code>innov</code> will be generated using 
the random number generator specified by <code>rand.gen</code>. 
Missing values are not allowed. By default the normal
random number generator will be used.
</td></tr>
<tr valign="top"><td><code>lag.max</code></td>
<td>
[armaTrueacf] - <br>
maximum number of lags at which to calculate the acf or 
pacf, an integer value by default 20.
</td></tr>
<tr valign="top"><td><code>method</code></td>
<td>
[armaFit] - <br>
a character string denoting the method used to fit the model.
The default method for all models is the log-likelihood parameter 
estimation approach, <code>method="mle"</code>. In the case of an AR
model the parameter estimation can also be done by ordinary least
square estimation, <code>"ols"</code>. 
</td></tr>
<tr valign="top"><td><code>model</code></td>
<td>
[armaSim] - <br>
a list with one (AR), two (ARMA) or three (ARIMA, FRACDIFF) 
elements . <code>ar</code> is a numeric vector giving the AR coefficients, 
<code>d</code> is an integer value giving the degree of differencing,
and <code>ma</code> is a numeric vector giving the MA coefficients.
Thus the order of the time series process is (F)ARIMA(p, d, q)
with <code>p=length(ar)</code> and <code>q=length(ma)</code>. <code>d</code> is
a positive integer for ARIMA models and a numeric value for
FRACDIFF models. By default an ARIMA(2, 0, 1) model with 
coefficients <code>ar=c(0.5, -0.5)</code> and <code>ma=0.1</code> will be 
generated.
<br>
[armaTrueacf][armaFischer] - <br>
a specification of the ARMA model with two elements:
<code>model$ar</code> is the vector of the AR coefficients, and 
<code>model$ma</code> is the vector of the MA coefficients.
</td></tr>
<tr valign="top"><td><code>n</code></td>
<td>
[armaSim] - <br>
an integer value setting the length of the series to be simulated 
(optional if <code>innov</code> is provided). The default value is 100.
</td></tr>
<tr valign="top"><td><code>n.ahead, n.back, conf</code></td>
<td>
[print][plot][summary][predict] - <br>
are presetted arguments for the <code>predict</code> method. <code>n.ahead</code>
determines how far ahead forecasts should be evaluated together
with errors on the confidence intervals given by the argument
<code>conf</code>. If a forecast plot is desired, which is the
default and expressed by <code>doplot=TRUE</code>, then <code>n.back</code> 
sets the number of time steps back displayed in the graph.
</td></tr>
<tr valign="top"><td><code>n.plot</code></td>
<td>
[armaRoots] - <br>
the number of data point to plot the unit circle;
an integer value.
</td></tr>
<tr valign="top"><td><code>n.start</code></td>
<td>
[armaSim] - <br>
gives the number of start-up values discarded when simulating 
non-stationary models. The start-up innovations will be generated 
by <code>rand.gen</code> if <code>start.innov</code> is not provided.
</td></tr>
<tr valign="top"><td><code>object</code></td>
<td>
[summary][predict] - <br>
is an object of class <code>fARMA</code> returned by the fitting function 
<code>armaFit</code> and serves as input for the <code>summary</code>, and 
<code>predict</code> methods. Some methods allow for additional 
arguments.
</td></tr>
<tr valign="top"><td><code>rand.gen</code></td>
<td>
[armaSim] - <br>
is the function which is called to generate the innovations. 
Usually, <code>rand.gen</code> will be a random number generator. 
Additional arguments required by the random number generator 
<code>rand.gen</code>, usually the location, scale and/or shape 
parameter of the underlying distribution function, have to be 
passed through the <code>dots</code> argument.
</td></tr>
<tr valign="top"><td><code>rseed</code></td>
<td>
[armaSim] - <br>
the random number seed, by default NULL. If this argument is
set to an integervalue, then the function <code>set.seed(rseed)</code>
will be called.
</td></tr>
<tr valign="top"><td><code>start.innov</code></td>
<td>
[armaSim] - <br>
is a univariate time series or vector of innovations to be used 
as start up values. Missing values are not allowed.
</td></tr>
<tr valign="top"><td><code>title</code></td>
<td>
a character string which allows for a project title.
</td></tr>
<tr valign="top"><td><code>type</code></td>
<td>
[armaTrueacf] - <br>
a character string, "correlation" to compute the true 
autocorrelation function, "partial" to compute the true
partial autocorrelation function, or "both" if both
functions are desired. The start of one of the strings 
will suffice.
</td></tr>
<tr valign="top"><td><code>which</code></td>
<td>
[plot][summary] - <br>
if <code>which</code> is set to <code>"ask"</code> the function will 
interactively ask which plot should be displayed. This is
the default value for the <code>plot</code> method. If 
<code>which="all"</code> is specified all plots will be displayed.
This is the default setting for the <code>summary</code> method.
On the other hand, if a vector of logicals is specified,
then those plots will be displayed for which the elements 
of the vector are set to <code>TRUE</code>.
</td></tr>
<tr valign="top"><td><code>x</code></td>
<td>
[print][plot] - <br>
is an object of class <code>fARMA</code> returned by the fitting 
function <code>armaFit</code> and serves as input for the <code>predict</code>, 
<code>print</code>, <code>print.summary</code>, and <code>plot</code> methods. 
Some methods allow for additional arguments.
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
additional arguments to be passed.
</td></tr>
</table>

<h3>Details</h3>

<p>
<B>AR - Auto-Regressive Modelling:</B>
<br><br>
The argument <code>x~ar(p)</code> calls the underlying functions 
<code>ar.yw</code>, <code>ar.burg1</code>, <code>ar.burg2</code>, code{<a href="onclick="findlink('stats', 'ar.ols.html')" style="text-decoration: underline; color: blue; cursor: hand"">ar.ols</a>} 
or <code>ar.mle</code>. 
For definiteness, the AR models are defined through
</p>
<p align="center"><i><code>(x[t] - m) = a[1]*(x[t-1] - m) + ... +  a[p]*(x[t-p] - m) + e[t]</code></i></p>
<p>
Order selection can be achieved through the comparison of AIC
values for different model specifications. However this may be
problematic, as of the methods here only <code>ar.mle</code> performs
true maximum likelihood estimation. The AIC is computed as if 
the variance estimate were the MLE, omitting the determinant 
term from the likelihood. Note that this is not the same as the 
Gaussian likelihood evaluated at the estimated parameter values. 
With <code>method="yw"</code> the variance matrix of the innovations is
computed from the fitted coefficients and the autocovariance of
<code>x</code>. Burg's method allows for two alternatives 
<code>method="burg1"</code> or <code>method="burg2"</code> to estimate the
innovations variance and hence AIC. Method 1 is to use the update 
given by the Levinson-Durbin recursion (Brockwell and Davis, 1991), 
and follows S-PLUS. Method 2 is the mean of the sum of squares of 
the forward and backward prediction errors (as in Brockwell and Davis, 
1996). Percival and Walden (1998) discuss both. 
<br>
<code>[stats:ar]</code>
<br>
</p>
<p>
<B>MA - Moving-Average Modelling:</B>
<br><br>   
The argument <code>x~ma(q)</code> maps the call to the
argument <code>x ~ arima(0, 0, q)</code>.
<br>
</p>
<p>
<B>ARMA - Auto-Regressive Moving-Average Modelling:</B>
<br><br>   
The argument <code>x~arma(p,q)</code> maps the call to the
argument <code>x~arima(p, 0, q)</code>.
<br>
</p>
<p>
<B>ARIMA - Integrated ARMA Modelling:</B>
<br><br>
The argument <code>x~arima()</code> calls the underlying function 
<code>arima</code> from <font face="Courier New,Courier" color="#666666"><b>R</b></font>'s <code>ts</code> package. For definiteness, the AR 
models are defined through
</p>
<p align="center"><i><code>x[t] = a[1]x[t-1] + ... + a[p]x[t-p] + e[t] + b[1]e[t-1] + ... + b[q]e[t-q]</code></i></p>
<p>
and so the MA coefficients differ in sign from those of
S-PLUS. Further, if <code>include.mean</code> is <code>TRUE</code>, this formula
applies to <i>x-m</i> rather than <i>x</i>.  For ARIMA models with
differencing, the differenced series follows a zero-mean ARMA model.
<br>
The variance matrix of the estimates is found from the Hessian of
the log-likelihood, and so may only be a rough guide.
<br>
Optimization is done by <code><a onclick="findlink('stats', 'optim.html')" style="text-decoration: underline; color: blue; cursor: hand">optim</a></code>. It will work
best if the columns in <code>xreg</code> are roughly scaled to zero mean
and unit variance, but does attempt to estimate suitable scalings.
The exact likelihood is computed via a state-space representation 
of the ARIMA process, and the innovations and their variance found 
by a Kalman filter. The initialization of the differenced ARMA 
process uses stationarity. For a differenced process the 
non-stationary components are given a diffuse prior (controlled 
by <code>kappa</code>). Observations which are still controlled by the 
diffuse prior (determined by having a Kalman gain of at least 
<code>1e4</code>) are excluded from the likelihood calculations. (This 
gives comparable results to <code><a onclick="findlink('stats', 'arima0.html')" style="text-decoration: underline; color: blue; cursor: hand">arima0</a></code> in the absence
of missing values, when the observations excluded are precisely those
dropped by the differencing.)
<br>
Missing values are allowed, and are handled exactly in method <code>"ML"</code>.
<br>
If <code>transform.pars</code> is true, the optimization is done using an
alternative parametrization which is a variation on that suggested by
Jones (1980) and ensures that the model is stationary.  For an AR(p)
model the parametrization is via the inverse tanh of the partial
autocorrelations: the same procedure is applied (separately) to the
AR and seasonal AR terms.  The MA terms are not constrained to be
invertible during optimization, but they will be converted to
invertible form after optimization if <code>transform.pars</code> is true.
<br>
Conditional sum-of-squares is provided mainly for expositional
purposes.  This computes the sum of squares of the fitted innovations
from observation <code>n.cond</code> on, (where <code>n.cond</code> is at least
the maximum lag of an AR term), treating all earlier innovations to
be zero.  Argument <code>n.cond</code> can be used to allow comparability
between different fits.  The ``part log-likelihood'' is the first
term, half the log of the estimated mean square.  Missing values
are allowed, but will cause many of the innovations to be missing.
<br>
When regressors are specified, they are orthogonalized prior to
fitting unless any of the coefficients is fixed. It can be helpful to
roughly scale the regressors to zero mean and unit variance.
<br>
Note from <code>arima</code>: The functions parse their arguments to the 
original time series functions available in <font face="Courier New,Courier" color="#666666"><b>R</b></font>'s time series library 
<code>ts</code>. 
<br>
The results are likely to be different from S-PLUS's
<code>arima.mle</code>, which computes a conditional likelihood and does
not include a mean in the model.  Further, the convention used by
<code>arima.mle</code> reverses the signs of the MA coefficients.
<br>
<code>[stats:arima]</code>
<br>
</p>
<p>
<B>FRACDIFF Modelling:</B>
<br><br>      
The argument <code>x~fracdiff()</code> calls the underlying functions from
<font face="Courier New,Courier" color="#666666"><b>R</b></font>'s <code>fracdiff</code> package. The estimator calculates the maximum 
likelihood estimators of the parameters of a fractionally-differenced 
ARIMA (p,d,q) model, together (if possible) with their estimated 
covariance and correlation matrices and standard errors, as well 
as the value of the maximized likelihood. The likelihood is 
approximated using the fast and accurate method of Haslett and 
Raftery (1989). Note, the number of AR and MA coefficients should 
not be too large (say &lt; 10) to avoid degeneracy in the model. 
<br>
The optimization is carried out in two levels: an outer univariate 
unimodal optimization in d over the interval [0,.5], and an inner 
nonlinear least-squares optimization in the AR and MA parameters to
minimize white noise variance.
<br>
<code>[fracdiff:fracdiff]</code>
</p>


<h3>Value</h3>

<p>
<code>armaFit</code> 
<br>
returns an S4 object of class <code>"fARMA"</code>, with the following 
slots:
</p>
<table summary="R argblock">
<tr valign="top"><td><code>call</code></td>
<td>
the matched function call.
</td></tr>
<tr valign="top"><td><code>data</code></td>
<td>
the input data in form of a data.frame.
</td></tr>
<tr valign="top"><td><code>description</code></td>
<td>
allows for a brief project description.
</td></tr>
<tr valign="top"><td><code>fit</code></td>
<td>
the results as a list returned from the underlying
time series model function. 
</td></tr>
<tr valign="top"><td><code>method</code></td>
<td>
the selected time series model naming the applied method.
</td></tr>
<tr valign="top"><td><code>formula</code></td>
<td>
the formula expression describing the model.
</td></tr>
<tr valign="top"><td><code>parameters</code></td>
<td>
named parameters or coefficients of the fitted model.
</td></tr>
<tr valign="top"><td><code>title</code></td>
<td>
a title string.
</td></tr>
</table>
<p>

<br>
<code>armaRoots</code> 
<br>
returns a three column data frame with the real, the imaginary part 
and the radius of the roots. The number of rows corresponds
to the coefficients.
<br>
<code>armaTrueacf</code>
<br>
returns a two column data frame with the lag and the correlation 
function.</p>

<h3>Note</h3>

<p>
There is nothing really new in this package. The benefit you will 
get with this collection is, that all functions have a common 
argument list with a formula to specify the model and presetted 
arguments for the specification of the algorithmic method. For 
users who have already modeled GARCH processes with SPlus, this 
approach will be quite natural.
</p>
<p>
The function <code>armaFit</code> allows for the following formula arguments:
</p>

<table summary="Rd table">
<tr>
  <td align="left"><code>x ~ ar()</code> </td>  <td align="left"> autoregressive time series processes, </td>
</tr>
<tr>
  <td align="left"> <code>x ~ ma()</code> </td>  <td align="left"> moving average time series processes, </td>
</tr>
<tr>
  <td align="left"> <code>x ~ arma()</code> </td>  <td align="left"> autoregressive moving average processes,</td>
</tr>
<tr>
  <td align="left"> <code>x ~ arima()</code> </td>  <td align="left"> autoregressive integrated moving average processes, and </td>
</tr>
<tr>
  <td align="left"> <code>x ~ arfima()</code> </td>  <td align="left"> fractionally integrated ARMA processes. </td>
</tr>
</table>

<p>
For the first selection <code>x~ar()</code> the function <code>armaFit()</code> 
uses the AR modelling algorithm as implemented in <font face="Courier New,Courier" color="#666666"><b>R</b></font>'s <code>stats</code> 
package. 
For the second <code>x~ma()</code>, third <code>x~arma()</code>, and fourth 
selection <code>x~arima()</code> the function <code>armaFit()</code> uses the 
ARMA modelling algorithm also as implemented in <font face="Courier New,Courier" color="#666666"><b>R</b></font>'s <code>stats</code> 
package.
For the last selection <code>x~fracdiff()</code> the function <code>armaFit()</code>
uses the fractional ARIMA modelling algorithm from <font face="Courier New,Courier" color="#666666"><b>R</b></font>'s contributed 
<code>fracdiff</code> package. Note, that the AR, MA, and ARMA processes 
can all be modelled by the same algorithm specifying the formula 
<code>x~arima(p,d,q)</code> in the proper way, i.e. setting <code>d=0</code> and 
choosing the orders of <code>p</code> and <code>q</code> as zero in agreement with 
the desired model specification.
</p>
<p>
Alternatively, one can still use the functions from R's <code>"stats"</code>
package: <code>arima.sim</code> that simulates from an ARIMA time series 
model, <code>ar, arima, arima0</code> that fit an AR, ARIMA model to an 
univariate time series, <code>predict</code> that forecasts from a fitted 
model, and <code>tsdiag</code> that plots time-series diagnostics. 
No function from these packages is masked, modified or overwritten.
</p>
<p>
The output of the <code>print</code>, <code>summary</code>, and <code>predict</code>
methods have all the same style of format for each time series
model with some additional algorithm specific printing. This makes 
it easier to interpret the results obtained from different algorithms 
implemented in different functions.
</p>
<p>
For <code>fracdiff</code> models the following methods are not yet
implemented: <code>plot</code>, <code>fitted</code>, <code>residuals</code>, 
<code>predict</code>, and <code>predictPlot</code>.
</p>


<h3>Author(s)</h3>

<p>
M. Plummer and B.D. Ripley for <code>ar</code> functions and code,<br>
B.D. Ripley for <code>arima</code> and <code>ARMAacf</code> functions and code, <br>
C. Fraley and F. Leisch for <code>fracdiff</code> functions and code, and <br>
Diethelm Wuertz for the Rmetrics <font face="Courier New,Courier" color="#666666"><b>R</b></font>-port.
</p>


<h3>References</h3>

<p>
Brockwell, P.J. and Davis, R.A. (1996); 
<EM>Introduction to Time Series and Forecasting</EM>, 
Second Edition, Springer, New York. 
</p>
<p>
Durbin, J. and Koopman, S.J. (2001); 
<EM>Time Series Analysis by State Space Methods</EM>,  
Oxford University Press.
</p>
<p>
Gardner, G, Harvey, A.C., Phillips, G.D.A. (1980); 
<EM>Algorithm AS154. An algorithm for exact maximum likelihood 
estimation of autoregressive-moving average models by means of 
Kalman filtering</EM>,
Applied Statistics, 29, 311&ndash;322.
</p>
<p>
Hannan E.J. and Rissanen J. (1982);
<EM>Recursive Estimation of Mixed Autoregressive-Moving 
Average Order.</EM>
Biometrika 69, 81&ndash;94. 
</p>
<p>
Harvey, A.C. (1993); 
<EM>Time Series Models</EM>,
2nd Edition, Harvester Wheatsheaf, Sections 3.3 and 4.4.
</p>
<p>
Jones, R.H. (1980); 
<EM>Maximum likelihood fitting of ARMA models to time
series with missing observations</EM>,
Technometrics, 20, 389&ndash;395.
</p>
<p>
Percival, D.P. and Walden, A.T. (1998); 
<EM>Spectral Analysis for Physical Applications.</EM> 
Cambridge University Press.
</p>
<p>
Whittle, P. (1963); 
<EM>On the fitting of multivariate autoregressions
and the approximate canonical factorization of a spectral 
matrix.</EM>
Biometrika 40, 129&ndash;134.
</p>
<p>
Haslett J. and Raftery A.E. (1989);
<EM>Space-time Modelling with Long-memory Dependence: Assessing 
Ireland's Wind Power Resource (with Discussion)</EM>,
Applied Statistics 38, 1&ndash;50.
</p>


<h3>Examples</h3>

<pre>
## SOURCE("fSeries.1A-ArmaModelling")
## Not run: 
## armaSim/armaFit -
   x = armaSim(model = list(ar = c(0.5, -0.5), ma = 0.1), n = 1000)
   # Estimate the parameters:
   fit = armaFit(x ~ arma(2, 1))
   print(fit)
   # Diagnostic Analysis:
   par(mfrow = c(3, 2), cex = 0.7)
   summary(fit)
   # 5 Steps ahead Forecasts:
   predict(fit, 5)
   
## armaRoots -
   # Calculate and plot the roots of an ARMA process:
   par(mfrow = c(2, 2), cex = 0.7)
   coefficients = c(-0.5, 0.9, -0.1, -0.5)
   armaRoots(coefficients)
   
## armaTrueacf -
   model = list(ar = c(0.3, +0.3), ma = 0.1)
   armaTrueacf(model)
   model = list(ar = c(0.3, -0.3), ma = 0.1)
   armaTrueacf(model)
## End(Not run)
</pre>

<script Language="JScript">
function findlink(pkg, fn) {
var Y, link;
Y = location.href.lastIndexOf("\\") + 1;
link = location.href.substring(0, Y);
link = link + "../../" + pkg + "/chtml/" + pkg + ".chm::/" + fn;
location.href = link;
}
</script>


<hr><div align="center">[Package <em>fSeries</em> version 231.10066 <a href="00Index.html">Index]</a></div>

</body></html>
