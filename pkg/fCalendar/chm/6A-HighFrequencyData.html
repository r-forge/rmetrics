<html><head><title>Tools for FX High Frequency Data</title>
<link rel="stylesheet" type="text/css" href="Rchm.css">
</head>
<body>

<table width="100%"><tr><td>HighFrequencyDataTools(fCalendar)</td><td align="right">R Documentation</td></tr></table><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e">
<param name="keyword" value="R:   HighFrequencyDataTools">
<param name="keyword" value="R:   xjulian">
<param name="keyword" value="R:   xdate">
<param name="keyword" value="R:   xday.of.week">
<param name="keyword" value="R:   xleap.year">
<param name="keyword" value="R:   fxdata.contributors">
<param name="keyword" value="R:   fxdata.parser">
<param name="keyword" value="R:   fxdata.filter">
<param name="keyword" value="R:   fxdata.varmin">
<param name="keyword" value="R:   xts.log">
<param name="keyword" value="R:   xts.diff">
<param name="keyword" value="R:   xts.cut">
<param name="keyword" value="R:   xts.interp">
<param name="keyword" value="R:   xts.map">
<param name="keyword" value="R:   xts.upsilon">
<param name="keyword" value="R:   xts.dvs">
<param name="keyword" value="R:   xts.dwh">
<param name="keyword" value=" Tools for FX High Frequency Data">
</object>


<h2>Tools for FX High Frequency Data</h2>


<h3>Description</h3>

<p>
A collection and description of functions for the 
management of high frequency financial market time 
series, especially for FX series collected from a 
Reuters data feed. The collection includes functions 
for the management of dates and times formatted in 
the ISO-8601 string 'CCYYMMDDhhmm', functions for 
filter and outlier detection of high frequency FX 
data records as collected from a Reuters data feed, 
and functions which can be used to calculate log-prices, 
log-returns, to extract subsamples, to interpolate 
in time, to build business time scales, and to 
de-seasonalize and de-volatilize high frequency 
financial market data.
<br>
</p>
<p>
'CCYYMMDDhhmm' Dates and Times functions are:
</p>

<table summary="Rd table">
<tr>
  <td align="left"><code>xjulian</code> </td>  <td align="left"> Julian minute counts for 'CCYYMMDDhhmm' formats, </td>
</tr>
<tr>
  <td align="left"> <code>xdate</code> </td>  <td align="left"> 'CCYYMMDDhhmm' from Julian minute counts, </td>
</tr>
<tr>
  <td align="left"> <code>xday.of.week</code> </td>  <td align="left"> day of week from 'CCYYMMDDhhmm' dates/times, </td>
</tr>
<tr>
  <td align="left"> <code>xleap.year</code> </td>  <td align="left"> Decides if 'CCYYMMDDhhmm' is a leap year or not. </td>
</tr>
</table>
            
</p>
<p>
Filter and outlier detection functions are: 
</p>

<table summary="Rd table">
<tr>
  <td align="left"><code>fxdata.contributors</code> </td>  <td align="left"> Creates a table with contributor names, </td>
</tr>
<tr>
  <td align="left">   <code>fxdata.parser</code> </td>  <td align="left"> Parses FX contributors and delay times, </td>
</tr>
<tr>
  <td align="left"> <code>fxdata.filter</code> </td>  <td align="left"> Filters price and spread values from FX records, </td>
</tr>
<tr>
  <td align="left"> <code>fxdata.varmin</code> </td>  <td align="left"> Aggregates records to variable minutes format. </td>
</tr>
</table>

<p>
Functions for De-Seasonalization and De-Volatilization:
</p>

<table summary="Rd table">
<tr>
  <td align="left"><code>xts.log</code> </td>  <td align="left"> Calculates logarithms for xts time series values, </td>
</tr>
<tr>
  <td align="left"> <code>xts.diff</code> </td>  <td align="left"> Differentiates xts time series values with lag=1, </td>
</tr>
<tr>
  <td align="left"> <code>xts.cut</code> </td>  <td align="left"> Cuts a piece out of a xts time series, </td>
</tr>
<tr>
  <td align="left"> <code>xts.interp</code> </td>  <td align="left"> Interpolates for equidistant time steps, </td>
</tr>
<tr>
  <td align="left"> <code>xts.map</code> </td>  <td align="left"> Creates a volatility adjusted time-mapping, </td>
</tr>
<tr>
  <td align="left">  <code>xts.upsilon</code> </td>  <td align="left"> Interpolates a time series in upsilon time, </td>
</tr>
<tr>
  <td align="left"> <code>xts.dvs</code> </td>  <td align="left"> Creates a de-volatilizised time series, </td>
</tr>
<tr>
  <td align="left"> <code>xts.dwh</code> </td>  <td align="left"> Plots intra-daily/weekly histograms. </td>
</tr>
</table>


<h3>Usage</h3>

<pre>
xjulian(xdates, origin = 19600101)
xdate(xjulians, origin = 19600101)
xday.of.week(xdates)
xleap.year(xdates)

fxdata.contributors(x, include = 10)
fxdata.parser(x, parser.table)
fxdata.filter(x, parameter = "strong", doprint = TRUE)
fxdata.varmin(x, digits = 4)

xts.log(xts)
xts.diff(xts)
xts.cut(xts, from.date, to.date)
xts.interp(xts, deltat = 1, method = "constant")
xts.map(xts, mean.deltat, alpha) 
xts.upsilon(xts, weekly.map = seq(from = 59, by =60, length = 168), 
    method = "constant", doplot = TRUE, ...)
xts.dvs(xts, k, volatility, doplot = TRUE, ...) 
xts.dwh(xts, deltat = 60, period = "weekly", dolog = TRUE, 
    dodiff = TRUE, doplot = TRUE) 
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>alpha</code></td>
<td>
the scaling exponent, a numeric value. For a random
walk this will be 2.
</td></tr>
<tr valign="top"><td><code>deltat</code></td>
<td>
the time in minutes between interpolated data points, 
by default 1 minute.
</td></tr>
<tr valign="top"><td><code>digits</code></td>
<td>
an integer value, the number of digits for the
<code>BID</code> and <code>ASK</code> price. By default five.
</td></tr>
<tr valign="top"><td><code>dolog, dodiff</code></td>
<td>
two logicals. Should the logarithm of the input data be taken?
Should the difference of the input data be taken?
Note, if both <code>dolog</code> and <code>dodiff</code> are set to true, 
the input data are expected to be price values.
</td></tr>
<tr valign="top"><td><code>doplot</code></td>
<td>
a logical. Should a plot be displayed?
</td></tr>
<tr valign="top"><td><code>doprint</code></td>
<td>
a logical, should the filter parameters be printed?
</td></tr>
<tr valign="top"><td><code>from.date, to.date</code></td>
<td>
ISO-8601 start and end dates, [CCYYMMDD].
</td></tr>
<tr valign="top"><td><code>include</code></td>
<td>
the contributors are sorted by frequency, the <code>include</code>
market makers are slected, an integer value. By default 10.)
</td></tr>
<tr valign="top"><td><code>k</code></td>
<td>
sampling frequency, an integer value. Takes values
on a sequence of the order of 10 data points.
</td></tr>
<tr valign="top"><td><code>mean.deltat</code></td>
<td>
the average size of the time intervals in minutes, an
integer value.
</td></tr>
<tr valign="top"><td><code>method</code></td>
<td>
a character string naming the interpolation method, either
"linear" or "constant".
</td></tr>
<tr valign="top"><td><code>origin</code></td>
<td>
the origin date of the counter, in ISO-8601 date format,
[CCYYMMDDhhmm]. By default January 1st, 1960.
</td></tr>
<tr valign="top"><td><code>parameter</code></td>
<td>
a character string, either <code>strong</code> or <code>weak</code>
denoting the filter parameter settings.
</td></tr>
<tr valign="top"><td><code>parser.table</code></td>
<td>
the table of contributors produced by <code>fxdata.contributors</code>,
a data.frame. In this table market leaders are marked.
</td></tr>
<tr valign="top"><td><code>period</code></td>
<td>
a string, either "weekly", "daily" or "both" selecting the 
type of the histogram. By default "weekly".
</td></tr>
<tr valign="top"><td><code>volatility</code></td>
<td>
average volatility, a numeric value. Takes values
of the order of the variance of the time series data.
</td></tr>
<tr valign="top"><td><code>weekly.map</code></td>
<td>
an integer vector of time intervals, by default 168
hourly intervals, spanning one week. Volatility
based maps can be created by the function <code>xts.map</code>.
</td></tr>
<tr valign="top"><td><code>x</code></td>
<td>
a 6 column standardized FX data frame with XDATE, DELAY, 
CONTRIBUTOR, BID, ASKL and FLAG fields.
</td></tr>
<tr valign="top"><td><code>xdates</code></td>
<td>
a numeric vector of ISO-8601 formatted Gregorian dates/times, <br>
[CCYYMMDDhhmm].
</td></tr>
<tr valign="top"><td><code>xjulians</code></td>
<td>
a numeric vector of Julian Minute Counts.
</td></tr>
<tr valign="top"><td><code>xts</code></td>
<td>
a list with date/time <code>t</code> in ISO-8601
format, [CCYYMMDDhhmm], and data values <code>x</code>.
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
arguments to be passed.
</td></tr>
</table>

<h3>Details</h3>

<p>
<B>Date and Time Functions:</B>
<br><br>
Note, that the <code>x*</code> indicates "extended" Date format including 
Time management functionality, whereas in <code>sjulian</code>, <code>sdate</code>, 
etc. the <code>s*</code> indicates "standard" or "simple" Date format, 
handling days, months years and centuries.
<br><br>
</p>
<p>
<B>The Data Preprocessing Process:</B>
<br><br>
<code>fxdata.contributors</code> creates a contributor list from a 
FX high frequency from a Reuters data feed and marks the market 
leaders. <code>fxdata.parser</code> selects with the information from
the contributors list data records from market leaders. As input
serves a standardized high frequency data file. Then the function
<code>fxdata.filter</code> filters the FX data records and finally
the function <code>fxdata.varmin</code> creates a "variable 
minutes" formatted data file, i.e. all data records within the same 
minute are averaged. The preprocessed data are the starting point
for further investiuagtions.
<br>
</p>
<p>
<B>The Standardized FX high frequency data file structure:</B>
<br><br>
<code>x</code> is a standardized data frame with 6 columns. The first 
column gives the dates/time <code>XDATE</code> in ISO-8601 format 
[CCYYMMDDhhmm], the second column is a measure for the feed 
<code>DELAY</code>, the third column denotes the <code>CONTRIBUTOR</code> 
code, the fifth and six columns are the <code>BID</code> and <code>ASK</code> 
price, and the last column is an information <code>FLAG</code>, to 
add additional information. 
<br>
</p>
<p>
<B>The Contributor List:</B>
<br><br>
The output of the <code>fxdata.contributors</code> function is used 
as input for the function 
<code>fxdata.parser</code>, which allows to extract the contributors 
marked as market makers in the output table.
<br>
</p>
<p>
<B>The Parser:</B>
<br><br>
The functions <code>fxdata.parser</code> parses the data.
The parser table, <code>parser.table</code>, is a data frame with 4 
columns: <code>CONTRIBUTOR</code> denotes a code naming the contributor, 
<code>COUNTS</code> gives the number of counts, how often the contributor 
appeared in the file, <code>PERCENT</code> the same as a percent value,
<code>SELECT</code> denotes a logical valie, if TRUE the contributor 
belongs to the group of the market makers, otherwise not.
<br>
</p>
<p>
<B>Variable Minutes Formatted Files:</B>
<br><br>
The function <code>fxdata.varmin</code>
creates data records within a variable minutes format.
<br>
</p>
<p>
<B>Log Prices and Log Returns:</B>
<br><br>
The function <code>xts.log</code> is mainly used to create log-prices from 
high frequency price records and the function <code>xts.diff</code>
is used to create log-returns. 
<br>
</p>
<p>
<B>Subsamples:</B>
<br><br>
Th function <code>xts.cut</code> is mainly used to create a subsample from
data records. If the start and/or end date are out of the time range 
the time series is simply forward/backward extrapolated with the first 
and/or last value.
<br>
</p>
<p>
<B>Interpolation:</B>
<br><br>
The function <code>xts.interp</code> is used to interpolate data records. 
The method allows for two different kinds of interpolations, either 
<code>"linear"</code> for a linear interpolation or <code>"constant"</code> for 
a constant interpolation keeping the previous value in time (left 
value) within the interpolation region.
<br>
</p>
<p>
<B>Business Time Maps:</B>
<br><br>
The function <code>xts.map</code> is mainly used to create the time map 
required by the 
function <code>xts.upsilon</code>. Important: The argument <code>xts</code> must 
start on a Monday and end on a Sunday. Use <code>xts.cut</code> to guarantue 
this.
<br>
</p>
<p>
<B>De-Seasonalization:</B>
<br><br>
The function <code>xts.upsilon</code> is  used to create data records with 
volatility 
adjusted time steps obtained from the "upsilon time" approach. These 
time steps can be taken from the time map crreated by the function 
<code>xts.map</code>. The data records are interpolated according to this 
time schedule.
<br>
</p>
<p>
<B>De-Volatilization:</B>
<br><br>
The de-volatilization algorithm is based on Zhou's approach. The
algorithm used by the function <code>xts.dvs</code> reduces the sample
frequency by keeping the variance of 
the price changes constant, therefore the name "de-volatilization". 
The procedure removes volatility by sampling data at different dates 
for different times. When the market is highly volatile more data are
sampled. Equivalently, the time is stretched. When the market is
less volatile, less data are sampled. Equivalently, the time is
compressed. Although the resulting subsequence has unequally space
calendar date/time intervals, it produces an almost equally volatile
time series. This time series is called a de-volatilized time
series, or "dv-Series".
<br>
</p>
<p>
<B>Daily/Weekly Historgram Plots:</B>
<br><br>
Financial market data exhibit seasonal structures over the day or 
week. This can be made explicit by daily or weekly histogram plots 
of the data using the function <code>xts.dwh</code>.
</p>


<h3>Value</h3>

<p>
<B>Date and Time Functions:</B>
<br>
<br>
<code>xjulian</code>
<br>
returns a numeric vector of Julian minute counts.
<br>
<br>
<code>xdates</code>
<br>
returns a numeric vector of ISO-8601 formatted dates/times, i.e.
[CCYYMMDDhhmm].
<br>
<br>
<code>xday.of.week</code>
<br>
returns a numeric vector with entries  between <code>0</code> (Sunday) and 
<code>6</code> (Saturday).
<br>
<br>
<code>xleap.year</code>
<br>
returns a logical vector with entries TRUE or FALSE, weather the date 
falls in a leap year or not.
<br>
<br>
<B>Filter and Outlier Detection:</B>
<br>
<br>
<code>fxdata.contributors</code>
<br>
returns a dataframe with the following columns: <code>CONTRIBUTOR</code>, 
the code naming the contributor, a character string; <code>COUNTS</code>, 
the counts, how often the contributor appeared in the file, an integer;
<code>PERCENT</code>, the same in percent, a numeric value; <code>SELECT</code>, 
a logical. If TRUE the contributor belongs to the group of the 
<code>n</code> market makers, otherwise not.
<br>
<br>
<code>fxdata.parser</code>, <code>fxdata.filter</code>
<br>
return a data frame with the same structure as <code>x</code>, i.e. a 
standardized FX high frequencey data file structure.
<br>
<br>
<code>fxdata.varmin</code>
<br>
return a data frame with the same structure as <code>x</code>, i.e. a 
standardized FX high frequencey data file structure. The second column 
named <code>DELAY</code> is not used and set to zero for each data record. The 
third column <code>CONTRIBUTOR</code> is set to "MEAN", the method how the 
variable minute record was evaluated. The last column <code>FLAG</code>
count the number of values from which the variable minute data 
record was evaluated.
<br>
<br>
<B>De-seasonalization and de-volatilization:</B>
<br>
<br>
All functions beside <code>xts.map</code> and <code>xts.dwh</code> return a
list with the following two components:
<code>t</code>, the date/time in ISO8601 format, [CCYYMMDDhhmm], the same
as the input data <code>xts$t</code>,
<code>x</code>, the logarithmic values of the input data records <code>xts$x</code>, 
a numeric vector.
<br>
<br>
<code>xts.map</code>
<br>
returns list with the following two components:
<code>xmap</code>, a numeric vector with the time intervals,
<code>ymap</code>, a numeric vector, the values to be mapped.
<br>
<br>
<code>xts.dws</code>
<br> 
If <code>daily</code> was selected, a list with the following two 
components is returned: 
<code>td</code>, the daily histogram breaks,
<code>xd</code>, the daily histogram freqencies.<br>
If <code>weekly</code> was selected, a list with the following two 
components is returned: 
<code>tw</code>, the weekly histogram breaks,
<code>xw</code>, the weekly histogram freqencies,<br>
If <code>both</code> was selected, a list with all four components 
is returned.</p>

<h3>Note</h3>

<p>
These functions were written originally for R Version 1.5. Only
minor changes were made to make these functions available for
Version 1.9. Date and time classes are outdated, but the functions
are still working.
</p>
<p>
The file <code>fdax97m.csv</code> is too large and therefore not part of 
the <code>fBasics</code> distribution. Please contact <EM>inf@rmetrics.org</EM>.
</p>


<h3>Author(s)</h3>

<p>
Diethelm Wuertz for the Rmetrics <font face="Courier New,Courier" color="#666666"><b>R</b></font>-port.
</p>


<h3>References</h3>

<p>
ISO-8601 (1988); 
<EM>Data Elements and Interchange Formats -
Information Interchange, Representation of Dates and Time</EM>,
International Organization for Standardization,
Reference Number ISO 8601, 14 pages.
</p>
<p>
Zhou B. (1995);
<EM>Forecasting Foreign Exchange Rates Subject to De-volatilization</EM>, 
in: Freedman R.S., Klein A.R., Lederman J. eds., Artificial Intelligence 
in the Capital Markets, Irwin Publishing, Chicago, p. 137&ndash;156.
</p>
<p>
Guillaume D.M., Dacorogna M.M., Dave R.R., Mueller U.A., Olsen R.B., 
Pictet O.V. (1997); 
<EM>From the bird's eye to the microscope: 
a survey of new stylized facts of the intra-daily foreign 
exchange markets</EM>, 
Finance and Stochastics 1, 95&ndash;129.
</p>


<h3>Examples</h3>

<pre>
## SOURCE("fCalendar.6A-HighFrequencyData")
## Not run: 
## xjulian - 
   # Julian Counts:
   # Return the number of minute counts for the last day in every 
   # month for year 2000 beginning January 1st, 2001 at 16:00:
   xjulian(c(
     20000131, 20000229, 20000331, 20000430, 20000531, 20000630,
     20000731, 20000831, 20000930, 20001031, 20001130, 20001231)*10000 + 
     1600, origin = 20000101)
   # This doesn't work in S-Plus, you get a sequence of NA's,
   # use instead:
   xjulian(c(
     200001311600, 200002291600, 200003311600, 200004301600, 200005311600, 
     200006301600, 200007311600, 200008311600, 200009301600, 200010311600, 
     200011301600, 200012311600), origin = 20000101)
     
## xdate - 
   # Convert Julian Counts to Dates:
   # Return the number of minute counts for th
   # Manage Date/Time in Extended Date/Time Format, ISO-8601
   # Date: 1973-01-01 15:30
   xjulian(197301011530)
   print(xdate(xjulian(197301011530)), digits = 9)
  
## xday.of.week -
   # Calculate the day of week for 1973-01-01 16:15
   # Compute Day of Week:
   xday.of.week(197301011615)
        
## xleap.year -
   # Check for Leap Years:
   # Falls Februar 1st, 2000 16:15 in a leap year?
   xleap.year(200002011615)    
   
## fxdata.contributors - 
   # Filter Contributors:
   # Print contributor list:
   data(usdthb)
   usdthb[1:25, ]
   # Create contributor list:
   fxdata.contributors(usdthb, include = 5)
   
## fxdata.parser - 
   # Parse Data:
   # Create a contributor list and mark the first 5 market makers:
   parser.table = fxdata.contributors(usdthb, include = 5)
   # Parse the market makers and print the first 25 entries:
   fxdata.parser(usdthb, parser.table)[1:25, ]
   
## fxdata.filter - 
   # Filter Records:
   # Filter data and plot unfiltered data:
   par(mfrow = c(2, 1))
   NumberOfRecords = length(usdthb[,1])
   NumberOfRecords
   plot(usdthb[,4], type = "l", 
        xlab = "Tick Number from Reuters THB=", 
        ylab = "100*log(Bid[n]/Bid[1])      Bid",
        ylim = c(-20,30), main="USDTHB June 1997 unfiltered")
   lines(x = c(1, NumberOfRecords), y = rep(usdthb[1, 4], 2), col = "steelblue")
   lines(-100*log(usdthb[1, 4]/usdthb[, 4]))
   lines(x = c(1, NumberOfRecords), y = c(0, 0), col = "steelblue")
   # Filter the data:
   usdthb = fxdata.filter(usdthb, parameter = "strong")
   # Quick And Dirty Time Scaling
   Records = length(usdthb$accepted[, 4])
   scale = NumberOfRecords/Records
   # Plot filtered data:
   plot(x=(1:Records)*scale, y = usdthb$accepted[, 4], type = "l", 
        xlab = "Tick Number from Reuters THB=", 
        ylab = "100*log(Bid[n]/Bid[1])      Bid", 
        ylim = c(-20, 30), main = "USDTHB June 1997 filtered")
   y = rep(usdthb$accepted[1, 4], 2)
   lines(x = c(1, NumberOfRecords), y = y, col = "steelblue")
   y = -100*log(usdthb$accepted[1, 4]/usdthb$accepted[, 4])
   lines(x = (1:Records)*scale, y = y)
   lines(x = c(1, NumberOfRecords), y = c(0, 0), col = "steelblue")
   
## fxdata.varmin - 
   # Variable Minute Records:
   # Variable Minute Records from filter accepted Data,
   # create a varmin file and print the first 25 entries:
   fxdata.varmin(usdthb$accepted, digits = 5)[1:25, ]  
   
## xts.log - 
   # Log Prices of FX Data:
   # Calculate log-prices from AUDUSD bid prices
   options(digits = 10)
   data(audusd)
   prices = list(t = audusd[,"XDATE"], x = audusd[,"BID"])
   # Print the first 25 entries:
   log.prices = xts.log(prices)
   data.frame(log.prices)[1:25, ]
   
## xts.diff - 
   # Returns of FX Data:
   # Calculate one hourly AUDUSD log-returns
   prices = list(t = audusd[,"XDATE"], x = audusd[,"BID"])
   # Calculate the returns and print the first 25 entries:
   data.frame(xts.diff(xts.log(prices)))[1:25, ]
   
## xts.cut - 
   # Cut out a Piece From a FX File:
   # Retrieve the AUDUSD bid quotes for October 21, 1997, 16:00 
   prices = list(t = audusd[,"XDATE"], x = audusd[,"BID"])
   # Retrieve prices and print the first 25 entries:
   data.frame(xts.cut(prices, from.date = 19971021, 
     to.date = 19971021))[1:25, ]

## xts.interp - 
   # Interpolate of FX Data:
   # Interpolate AUDUSD bid prices 
   # on a 15 minutes  time scale for October 21, 1997:
   prices = list(t = audusd[,"XDATE"], x = audusd[,"BID"])
   # Interpolate the prices and print the first 25 entries:
   data.frame(xts.interp(prices, deltat = 15))[1:25, ]
   
## xts.map - 
   # Create Business Time Map:
   options(object.size = 5e8)
   par(mfrow = c(2, 1))
   # Load and plot prices:
   data(fdax9710)
   index = list(t = fdax9710[,"XDATE"], x = fdax9710[,"FDAX"])  
   # Start on Monday - end on Sunday, 3 weeks:
   index = xts.cut(index, from.date=19971006, to.date=19971026)
   plot(index$x, type = "l", xlab = "Prices", main = "Prices in event time")   
   # Create hourly upsilon time map - start on Monday - end on Sunday:
   tmap = xts.map(index, mean.deltat = 60, alpha = 1.05)
   plot(x = tmap$xmap, y = tmap$ymap, ylim = c(0, max(tmap$x)), type="l", 
     main = "Time Mapping")   
   tmap 
   
## xts.upsilon -  
   # De-seasonalize in Upsilon Time:
   index = list(t = fdax9710[,"XDATE"], x = fdax9710[,"FDAX"])  
   # Start on Monday - end on Sunday, 3 weeks:
   index = xts.cut(index, from.date = 19971006, to.date = 19971026)
   plot(index$x, type = "l", xlab = "Prices", main = "Prices in event time")   
   # Create hourly upsilon time map - start on Monday - end on Sunday:
   tmap = xts.map(index, mean.deltat = 60, alpha = 1.05)
   # Extract data records according to time map:
   index.ups = xts.upsilon(index, weekly.map = tmap$ymap, 
     main="Prices in Upsilon time")
    
## xts.dvs - 
   # De-volatilize Time Series:
   index = list(t=fdax9710[,"XDATE"], x=fdax9710[,"FDAX"])  
   # Start on Monday - end on Sunday, 3 weeks:
   index = xts.cut(index, from.date=19971006, to.date=19971026)
   plot(index$x, type = "l", ylab = "Prices", main = "Prices in event time")    
   # Devolatilize Time Series With dv-Series Algorithm:
   index.dvs = xts.dvs(index, k = 8, 
     volatility = 13.15*var(diff(log(index$x))), main = "Prices from dv-series") 

## xts.dws -
   # Plot daily/weekly Charts:
   # NOTE:
   # The file this-is-escaped-code{ is too large and therefore not part 
   # of  this distribution. Please contact \emph{inf@rmetrics.org}.
   data(fdax97m)
   xts = list(t = fdax97m[,"XDATE"], x = fdax97m[,"FDAX"])
   # Start on Monday - end on Sunday, 3 weeks:
   xts = xts.cut(index, from.date = 19970106, to.date = 19971228)
   # Create Daily and Weekly Histograms:
   result = xts.dwh (xts, period = "both", dolog = TRUE, 
     dodiff = TRUE, deltat = 30, doplot = TRUE)     
## End(Not run)
</pre>



<hr><div align="center">[Package <em>fCalendar</em> version 231.10066 <a href="00Index.html">Index]</a></div>

</body></html>
