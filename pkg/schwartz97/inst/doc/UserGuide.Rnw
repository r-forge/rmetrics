\documentclass[a4paper,11pt]{article}
\usepackage[authoryear,round]{natbib}
\bibliographystyle{plainnat}
\usepackage{url}
\usepackage{a4wide}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[
colorlinks=true,
linkcolor=black,
anchorcolor=black,
citecolor=black,
filecolor=black,
pdfstartview={Fit},
pdfstartpage={1}
]
{hyperref}
\newcommand{\RR}{\textsf{R}}
\newcommand{\vnorm}[1]{\Vert#1\Vert} % Notation: 2-Norm of a Vector
\newcommand{\condexp}[2]{
  \mathbb{\tilde{E}}\left[#1\vert\mathcal{F}_{#2}\right]}
\newcommand{\condexprf}[2]{
  \mathbb{\tilde{E}}\left[#1\vert\mathcal{F}_{#2}\right]}
% Conditional Expectation
\newcommand{\Rpackage}{\textit{schwartz97}}
\newcommand{\sigmaS}{\sigma_S}
\newcommand{\sigmaE}{\sigma_\epsilon}
% <---------------------------------------------------------------------->
\SweaveOpts{engine=R,eps=TRUE}
%%\VignetteIndexEntry{User Guide}
\title{Using the \Rpackage{} package}
\author{Philipp Erb, David L\"{u}thi \& Simon Otziger}%\\\email{otis@zhaw.ch}}
\date{\today}
\begin{document}
\maketitle
\begin{abstract}
  The purpose of this document is to show how the \RR{} package
  \Rpackage{} can be used. This is done by numerous examples and
  intuitive explanations. 
\end{abstract}
<<echo=FALSE>>=
library(schwartz97)
@ 
%\tableofcontents
% <============================================================>
\section{Introduction}\label{sec:intro}
% <============================================================>
The package \Rpackage{} provides a set of functions to work with the
two-factor model of \cite{Gibson1990}\footnote{Because the model was
  extended in \cite{Schwartz1997} and \cite{Miltersen1998} we call it
  the \emph{Schwartz two-factor model} hereafter.}. The two-factor
model describes the joint dynamics of the state variables \emph{spot
  price} and \emph{spot convenience yield} (later simply called
\emph{convenience yield}).

We believe that the value of this package primarily lies in the
parameter fitting routine \verb=fit.schwartz2f=. Once the parameters
of the two-factor model are estimated, a number of functions can be
used to, e.g., draw samples from the model, price derivatives as
European options, or filter a futures price series to get an estimate
of the underlying state variables. The document is organized as
follows: Section \ref{sec:model} briefly describes the model and
section \ref{sec:overview} gives an overview of the classes and
functions. Then, section \ref{sec:init} to
\ref{sec:parameter-estimation} give examples and a case study.
% <============================================================>
\section{The Schwartz Two-Factor Model}\label{sec:model}
% <============================================================>
This model assumes the spot price of the commodity and the
instantaneous convenience yield to follow the joint stochastic
process:
\begin{eqnarray}
  dS_t &=& (\mu - \delta_t) S_t dt + \sigmaS S_t
  dW_S   \label{eq:Pdynamics-S} \\
  d\delta_t &=& \kappa (\alpha - \delta_t) dt + \sigmaE
  dW_\epsilon, \label{eq:Pdynamics-delta}
\end{eqnarray}
with Brownian motions $W_S$ and $W_\epsilon$ under the objective
measure $\mathbb{P}$ and correlation $dW_SdW_\epsilon = \rho dt$.
Under the pricing measure $\mathbb{Q}$ the dynamics are of the form
\begin{eqnarray}
  dS_t &=& (r - \delta_t) S_t dt + \sigmaS S_t
  d\widetilde{W}_S   \label{eq:Qdynamics-S} \\
  d\delta_t &=& [\kappa (\alpha - \delta_t) - \lambda] dt + \sigmaE
  d\widetilde{W}_\epsilon, \label{eq:Qdynamics-delta}
\end{eqnarray}
where the constant $\lambda$ denotes the market price of convenience
yield risk and $\widetilde{W}_S$ and $\widetilde{W}_\epsilon$ are
$\mathbb{Q}$-Brownian motions. It may be handy to introduce a new
mean-level for the convenience yield process under $\mathbb{Q}$
\begin{equation}
  \label{eq:Q-drift}
 \tilde{\alpha} = \alpha - \lambda / \kappa.
\end{equation}
The dynamics is then
\begin{equation}
d\delta_t = \kappa (\tilde{\alpha} - \delta_t) dt + \sigmaE
  d\widetilde{W}_\epsilon.
\end{equation}
For more information on the model and pricing formulas we refer to the
other package vignette \emph{Technical Document}, or to
\cite{Schwartz1997} and \cite{Hilliard1998}.
% <============================================================>
\section{Package Overview}\label{sec:overview}
% <============================================================>
This section gives an overview of the functions and classes contained
in the package \Rpackage. In addition, the object-oriented programming
approach followed in this package is explained.
% <------------------------------------------------------------>
\subsection{Functions}\label{sec:functions}
% <------------------------------------------------------------>
The core of the package \Rpackage{} is built by the following
functions\footnote{There are also a number of utility functions as
  \emph{coef}, \emph{mean}, \emph{vcov}, \emph{plot}, \emph{resid},
  and \emph{fitted}.}:
\begin{center}
  \begin{tabular}{l|l}
    R-function & Description \\
    \hline
    \verb=dstate= & Density of the bivariate state vector. \\
    \verb=pstate= & Distribution of the bivariate state vector. \\
    \verb=qstate= & Quantile of the bivariate state vector. \\
    \verb=rstate= & Sample from the state vector distribution at some time in the future. \\
    \verb=simstate= & Generate trajectories from the bivariate state vector. \\
    \verb=dfutures= & Density of the futures price. \\
    \verb=pfutures= & Distribution of the futures price. \\
    \verb=qfutures= & Quantile of the futures price. \\
    \verb=rfutures= & Sample from the futures price distribution. \\
    \verb=pricefutures= & Calculate the futures price. \\
    \verb=priceoption= & Calculate the price of European call or put options. \\
    \verb=filter.schwartz2f= & Filter a futures price series. \\
    \verb=fit.schwartz2f= & Fit the two-factor model to data. \\
  \end{tabular}
\end{center}
Except the function \verb=fit.schwartz2f= all the above
functions are set to generic and accept three different signatures
(see section \ref{sec:oop}). 
% <------------------------------------------------------------>
\subsection{Classes}\label{sec:classes}
% <------------------------------------------------------------>
The package \Rpackage{} provides the class \verb=schwartz2f=. This
class contains all parameters which are needed to define the dynamics
of the state variables \emph{spot price} and \emph{convenience yield}
under the objective measure $\mathbb{P}$. The class
\verb=schwartz2f= has the following slots:\\[1ex]
\begin{center}
  \begin{tabular}{llll}
    Slot name & Class & Symbol & Description\\
    \hline
    s0 & numeric & $s_0$ & Initial spot price.\\
    delta0 & numeric & $\delta_0$ & Initial convenience yield.\\
    mu & numeric & $\mu$ & Drift parameter of the spot price process.\\
    sigmaS & numeric & $\sigma_S$ & Diffusion parameter of the spot price process.\\
    kappaE & numeric & $\kappa$ & Speed of mean-reversion of the convenience yield process.\\
    alpha & numeric & $\alpha$ & Mean-level of the convenience yield process.\\
    sigmaE & numeric & $\sigma_\epsilon$ & Diffusion parameter of the convenience yield process.\\
    rhoSE & numeric & $\rho$ & Correlation between the two Brownian motions.\\
    call & call & & The function call.\\
  \end{tabular}
\end{center}
The above set of parameters contains the symbols appearing in
(\ref{eq:Pdynamics-S}) and (\ref{eq:Pdynamics-delta}) as well as the
initial values $s_0$ and $\delta_0$. To create an object of class
\verb=schwartz2f= the constructor with the same name can be used (see
section \ref{sec:init}).

The function \verb=fit.schwartz2f=, which estimates parameters of the
two-factor model, returns an object of class
\verb=schwartz2f.fit=. This class inherits from the class
\verb=schwartz2f= and adds the following slots.\\
\begin{center}
  \begin{tabular}{llll}
    Slot name & Class & Symbol & Description\\
    \hline
    r & numeric & $r$ & Risk-free interest rate.\\
    alphaT & numeric & $\tilde{\alpha}$ & Mean-value of the convenience yield process under $\mathbb{Q}$.\\
    lambda & numeric & $\lambda$ & Market price of convenience yield risk.\\
    deltat & numeric & & Time-increment of the transition equation.\\
    n.iter & numeric & & Number of iterations.\\
    llh & numeric & & Log-likelihood value.\\
    converged & logical & & States whether the fit converged or not.\\
    error.code & numeric & & An error code or $0$.\\
    error.message & character & & Contains the error message if any.\\
    fitted.params & logical & & States which  parameters were fitted.\\
    trace.pars & matrix & & Contains the parameter evolution during the estimation.\\
    meas.sd & numeric & & Standard deviation of the measurement equation.\\
    % lambda & numeric & $\lambda$ & Market price of convenience yield
    % risk.\\
    % alphaT & numeric & $\tilde{\alpha}$ & Drift parameter
    % $\tilde{\alpha}$ of the convenience yield under $\mathbb{Q}$.\\
    % r & numeric & $r$ & Risk-free interest-rate.\\
  \end{tabular}
\end{center}
These slots together with the ones contained in the class
\verb=schwartz2f= fully determine the dynamics of the model under
both, the objective measure and the pricing measure. Notice that one
of the parameters \verb=lambda= and \verb=alphaT= is redundant
according to equation \ref{eq:Q-drift}.
% <------------------------------------------------------------>
\subsection{Object Orientation}\label{sec:oop}
% <------------------------------------------------------------>
As mentioned earlier most of the functions dealing with the state
variables and futures prices are set to generic. The idea is to leave
some freedom to the user, who can decide whether he wants to use an
object-oriented approach or provide a fairly large set of arguments
for each function-call.

Consider the function \verb=dfutures= for example. The function
headers for different signatures are:
\begin{verbatim}
## S4 method for signature 'ANY,ANY,ANY,numeric':
dfutures(x, time = 0.1, ttm = 1, s0 = 50, delta0 = 0,
         mu = 0.1, sigmaS = 0.3, kappa = 1, alpha = 0,
         sigmaE = 0.5, rho = 0.75, r = 0.05, lambda = 0,
         alphaT = NULL, measure = c("P", "Q"), ...)

## S4 method for signature 'ANY,ANY,ANY,schwartz2f':
dfutures(x, time = 0.1, ttm = 1, s0, r = 0.05,
         lambda = 0, alphaT = NULL, measure = c("P", "Q"), ...)

## S4 method for signature 'ANY,ANY,ANY,schwartz2f.fit':
dfutures(x, time = 0.1, ttm = 1, s0, measure = c("P", "Q"), ...)
\end{verbatim}
Without object-orientation (first header) the function has 15
arguments. Ten parameters are needed to describe the dynamics under
both measures.

If a \verb=schwartz2f.fit= object is provided for \verb=s0= the only
additional arguments required are \verb=x= (quantiles), \verb=time=
(time where the futures process is evaluated), and \verb=ttm= (time to
maturity of the futures contract).
% <============================================================>
% <============================================================>
\section{Object Initialization}\label{sec:init}
% <============================================================>
A \verb=schwartz2f= object with reasonable parameters is
constructed in the following code chunk.
<<>>=
s0 <- 100
delta0 <- 0
mu <- 0.1
sigmaS <- 0.2
kappa <- 1
alpha <- 0.1
sigmaE <- 0.3
rho <- 0.4

obj <- schwartz2f(s0 = s0, delta0 = delta0, alpha = alpha,
                       mu = mu, sigmaS = sigmaS, sigmaE = sigmaE,
                       rho = rho, kappa = kappa)
obj
@

Objects of class \verb=schwartz2f.fit= are constructed via the
function \verb=fit.schwartz2f= (see section
\ref{sec:parameter-estimation}).
% <============================================================>
\section{Working with the state variables}\label{sec:state}
% <============================================================>
As soon as a \verb=schwartz2f= object is initialized, it can be passed
to the functions \verb=dstate=, \verb=pstate=, \verb=qstate=,
\verb=rstate=, and \verb=simstate=. The distribution of the state
variables depend on the horizon. Once this point in time is defined
the above functions can be used like the standard \RR{} distribution
functions for, e.g., the normal distribution (\verb=dnorm=,
\verb=pnorm=, \verb=qnorm=, \verb=rnorm=).

In this example a sample of the spot price and the convenience yield
in five years is generated by the function \verb=rstate=. Then, the
probability that the spot price is below 150 and the convenience yield
is lower than 0 in five years is computed. Finally, the mean of the
state variables in one and ten years is calculated. Figure
\ref{fig:state-trajectory} shows trajectories of the state variables.

<<>>=
time <- 5
sample.t <- rstate(n = 2000, time, obj)
pstate(c(0, -Inf), c(150, 0), time, obj)
mean(obj, time = c(1, 10))
@

\begin{figure}\centering
<<fig=TRUE,echo=TRUE>>=
plot(obj, n = 50, time = 5, dt = 1 / 52)
@
\caption{Fifty trajectories of the state variables are plotted on a
  weekly interval and a five years horizon. The initial values of the
  state variables are 100 for the spot price ($s_0$) and 0 for the
  convenience yield ($\delta_0$). The spot price has a drift $\mu$ of
  10\% and a volatility $\sigma_S$ of 20\%.  The \emph{speed of
    mean-reversion} parameter $\kappa$ of the convenience yield
  process is 1, and the long-term mean ($\alpha$) is 10\%.  The
  volatility of the convenience yield $\sigma_\epsilon$ is 30\% and
  the correlation $\rho$ between the Brownian motions driving the
  state variables is 40\%.}\label{fig:state-trajectory}
\end{figure}
% <============================================================>
\section{Working with derivatives}\label{sec:derivatives}
% <============================================================>
In this example we calculate some futures prices and plot the dynamics
of the term structure (``forward curve''). In addition prices of
European options are computed. We work through this section by looking
at corn and assuming all the parameters are known.

The current price ($s_0$) of 1000 bushels of corn is assumed to be 80
USD. The convenience is yield ($\delta_0$) is zero at the moment but
it's long-term mean ($\alpha$) is 5\%. The mean return ($\mu$) of corn
is 10\% and the volatility is 30\%. The speed of mean-reversion of the
convenience yield ($\kappa$) is 1.5 and its volatility is
40\%. Correlation is assumed to be 60\%. The risk-free rate is 3\% and
the market price of convenience yield risk ($\lambda$) is zero.

First the object is initialized. Next a trajectory is generated based
on a weekly sampling over five years. Then futures prices are
calculated with time to maturities ranging from zero (which is the
spot) to two years. Finally, a call option which matures in one year
written on a futures contract with time to maturity of two years is
priced. Fig. \ref{fig:forward-curves} plots forward curves.
<<>>=
s0 <- 80
delta0 <- 0.05
mu <- 0.1
sigmaS <- 0.3
kappa <- 1.5
alpha <- 0.05
sigmaE <- 0.4
rho <- 0.6
lambda <- 0.04
r <- 0.03
set.seed(1)
obj <- schwartz2f(s0, delta0, mu, sigmaS, kappa, alpha, sigmaE, rho)
state.traj <- simstate(n = 52 * time, time, obj)
pricefutures(seq(0, 2, by = 0.4), obj, lambda = lambda, r = r)
priceoption(type = "call", time = 1, Time = 2, K = 85,
            obj, r = r, lambda = lambda)
@
\setkeys{Gin}{width=\textwidth}
\begin{figure}\centering
<<fig=TRUE,echo=FALSE,height=7,width=9>>=
ttm <- seq(0, 2, by = 0.4)
forward.curves <- sapply(ttm, pricefutures, s0 = state.traj[,1], delta0 = state.traj[,2],
                         sigmaS = sigmaS, kappa = kappa, alpha = alpha, sigmaE = sigmaE,
                         lambda = lambda, r = r)
ttm.mat <- matrix(ttm, ncol = 6, nrow = 52 * time, byrow = TRUE)
dates <- Sys.Date() + seq(0, length = time * 52, by = 7)
rownames(ttm.mat) <- as.character(dates)
par(oma = c(6, 0, 5, 0), mfrow = c(2, 1), mar = c(0, 5.1, 0, 2.1))
## Prepare a list which is accepted by 'futuresplot'
futuresplot(list(price = forward.curves, ttm = ttm.mat * 260), xaxt = "n")
plot(dates, state.traj[,2], main = "", type = "l", ylab = "Convenience yield",
     xlim = c(dates[1], rev(dates)[1] + max(ttm) * 260))
abline(h = 0)

@
\caption{Forward curves with time to maturity up to two years are
  plotted for the trajectory \emph{state.traj}. The ``closest to
  maturity contract'' is in fact the spot price because the time to
  maturity is zero. The forward curves are steeper (stronger contango)
  the lower the convenience yield is.}\label{fig:forward-curves}
\end{figure}
% <============================================================>
\section{Contango and Backwardation}\label{sec:contango}
% <============================================================>
Fig. \ref{fig:forward-curves} shows the ability of the Schwartz
two-factor model to generate contango and backwardation
situations. Mixed shapes are possible too. E.g. an upwards sloping
forward curve at the short end which points downwards at the long end.

Looking at the $\mathbb{Q}$-dynamics in equations
(\ref{eq:Qdynamics-S}) and (\ref{eq:Qdynamics-delta}) it is obvious
that, locally, the drift of the spot price is positive when $\delta_t
< r$. This corresponds to a (local) contango situation. However, the
long-term mean of $\delta_t$ is $\tilde{\alpha}$. This means that
short and long-term futures can point in different directions.

Four different shapes are generated in the following example
\begin{description}
\item[Pure contango:]  If $r > \delta_0$ and $r > \tilde{\alpha}$.
\item[Backwardation first, then contango:] If $r < \delta_0$ and $r >
  \tilde{\alpha}$.
\item[Pure backwardation:]  If $r < \delta_0$ and $r < \tilde{\alpha}$.
\item[Contango first, then backwardation:]  If $r > \delta_0$ and $r < \tilde{\alpha}$.  
\end{description}
<<>>=
s0 <- 1
delta0 <- 0.0
sigmaS <- 0.3
kappa <- 1
sigmaE <- 0.4
rho <- 0.5
r <- 0.03
ttm <- seq(0, 3, by = 0.5)
## Pure contango
pricefutures(ttm, s0 = s0, delta0 = r, sigmaS = sigmaS,
             kappa = kappa, sigmaE = sigmaE, rho = rho,
             r = r, alphaT = r - 0.1)
## Backwardation and then contango
pricefutures(ttm, s0 = s0, delta0 = r + 0.1, sigmaS = sigmaS,
             kappa = kappa, sigmaE = sigmaE, rho = rho,
             r = r, alphaT = r - 0.1)
## Pure backwardation
pricefutures(ttm, s0 = s0, delta0 = r, sigmaS = sigmaS,
             kappa = kappa, sigmaE = sigmaE, rho = rho,
             r = r, alphaT = r + 0.1)
## Contango and then backwardation
pricefutures(ttm, s0 = s0, delta0 = r - 0.1, sigmaS = sigmaS,
             kappa = kappa, sigmaE = sigmaE, rho = rho,
             r = r, alphaT = r + 0.1)

@ 
\clearpage
% <============================================================>
\section{Parameter Estimation}\label{sec:parameter-estimation}
% <============================================================>
As mentioned in section \ref{sec:intro}, we think that the most
valuable piece of code of the package \Rpackage{} is in the function
\verb=fit.schwartz2f=. This function can estimate all the nine parameters
involved in equations (\ref{eq:Pdynamics-S}) -
(\ref{eq:Qdynamics-delta}) (including the initial values of the state
variables $s_0$ and $\delta_0$). The estimation procedure is based on
the Kalman filter.  Because the log-futures prices linearly depend on
two Gaussian random variables (the log-spot price and the convenience
yield), it is the most straightforward way to use a linear state-space
model.

The header of the function \verb=fit.schwartz2f= looks like

<<>>=
  args(fit.schwartz2f)
@

The only mandatory inputs are \verb=data= and \verb=ttm=. \verb=data=
must be a matrix of futures prices and \verb=ttm= a matrix giving the
time-to-maturity. The time-to-maturity matrix is interpreted the
following way: \verb=ttm[i,j]= corresponds to the time-to-maturity of
the futures price \verb=data[i,j]=.  The next nine arguments are
initial values of all parameters. The argument \verb=meas.sd= gives
the standard deviation of the measurement error. There must be a
measurement error standard deviation associated to each futures
series\footnote{For a detailed explanation consult the other package
  vignette \emph{Technical Document} or the article
  \cite{Schwartz1997}.}. \verb=opt.pars= is a vector of logicals
stating which parameters should be fitted. The argument
\verb=opt.meas.sd= defines how the measurement error standard
deviation will be treated. If \verb+opt.meas.sd == "scalar"+ it means
that \verb=meas.sd= is scaled by a single factor, which enters the
optimization procedure. During the optimization \verb=rho= is 
constrained to [-1, 1]. Finally, the risk-free rate must be
given.\\[2ex]
\textbf{Example:}\\
We have around 7000 daily observations from Jan. 1989 to Jan. 2009 of
8 simultaneously listed copper futures prices. Now, we want to
estimate the parameters. As the data must not have NA's, we first
compute the indexes of rows containing NA's. Then, we use the default
arguments of the function \verb=fit.schwartz2f= to estimate the
parameters. That is, all parameters except the initial values
\verb=s0= and \verb=delta0= are estimated and the standard deviation
of the measurement equation error is assumed to be equal for all
futures contracts (\verb+opt.meas.sd = "scalar"+). Notice that the
default values for \verb=s0= and \verb=delta0= are \verb=data[1,1]=
(the first observation of the closest to maturity futures) and 0,
respectively.
<<>>=
data(futures)

copper.fit <- fit.schwartz2f(futures$copper$price, futures$copper$ttm / 260,
                         control = list(maxit = 100, reltol = 1e-3),
                         silent = TRUE)
copper.fit

@

Let's spend a few words on the estimated parameters. As the initial
values of the state variables were not estimated, the first parameter
to discuss is the drift parameter of the spot price process
$\mu$. A value of approx. 20\% was estimated, which seems to be
reasonable. The volatility of the spot price process $\sigma_S$ was
found to be 37\%. This value makes sense, too.

Then, regarding the convenience yield process, three parameters were
estimated: The speed of mean-reversion parameter $\kappa$, the
long-term average parameter $\alpha$ and the volatility parameter
$\sigma_\epsilon$. The mean-reversion speed $\kappa$ was estimated to
be 1.1. It is hard to verify whether this value is sensible. But it
can be said that it is at least not far off. A reasonable mean-level
$\alpha$ of approx. 6\% was estimated. The volatility
$\sigma_\epsilon$ is found to be around 50\%, also a sensible value.

The correlation coefficient $\rho$ is pretty high at 81\% and the
market price of convenience yield risk $\lambda$ takes a realistic
value of 4\%.

We want to have a look at the spot price and the convenience
yield. Since we do not observe these variables, the data has to be
filtered to estimate the state variables. Figure
\ref{fig:filtered-state} shows a plot of the estimated spot price and
convenience yield.
<<>>=
filtered <- filter.schwartz2f(futures$copper$price, futures$copper$ttm / 260, copper.fit)
@
\begin{figure}\centering
<<fig=TRUE,echo=FALSE>>=
par(mfrow = c(2, 1))
plot(filtered$state[, "S"], type = "l", ylab = "",
     main = "State variables based on filtered futures prices")
lines(futures$copper$price[, 1], col = "blue", lty = "dotted")
legend("topleft", legend = c("Spot price",
                    "Closest to maturity futures"),
       lty = c("solid", "dotted"), col = c("black", "blue"))
plot(filtered$state[, "delta"], type = "l",
     ylab = "")
legend("top", legend = "Convenience yield")
@
\caption{Futures prices are filtered based on the parameters estimated
  by \textsf{fit.schwartz2f}. As a result of the function
  \textsf{filter.schwartz2f}, we obtain the spot price and the convenience
  yield. The top panel shows the estimated spot price together with
  the closest to maturity futures price. The prices can hardly be
  distinguished. The estimated convenience yield is plotted in the
  bottom panel. The range of the convenience yield $[-0.1, 0.5]$ seems
  to be reasonable.}\label{fig:filtered-state}
\end{figure}

The output of the fitting procedure was stored in the variable
\verb=copper.fit=. As this object is of class
\verb=schwartz2f.fit=, it contains all information needed to
price derivatives. To give an example, we calculate the price of a
European put option written on a copper futures with strike price
90. The futures expires in 3 years, and the option in 2 years. We also
calculate the 3 years futures price.
<<>>=
##priceoption("put", time = 2, Time = 3, K = 90, copper.fit)

pricefutures(ttm = 3, copper.fit)
@

% <---------------------------------------------------------------------->
\bibliography{SpotCommodity}
\end{document}
